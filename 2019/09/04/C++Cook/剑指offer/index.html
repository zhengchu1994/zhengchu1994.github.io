<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 4.2.1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-moon_32px.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-moon_32px.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-moon_16px.png?v=7.3.0">
  <link rel="mask-icon" href="/images/favicon-moon_32px.png?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":"mac"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="队列和栈 用两个栈实现队列的头部出队，尾部入队操作：1234567891011121314151617181920212223242526class Solution&amp;#123;public:    void push(int node) &amp;#123;        while(!stack2.empty())        &amp;#123;            stack1.push(stack2">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer--c++">
<meta property="og:url" content="http://yoursite.com/2019/09/04/C++Cook/%E5%89%91%E6%8C%87offer/index.html">
<meta property="og:site_name" content="Zheng Chu&#39;s Blog">
<meta property="og:description" content="队列和栈 用两个栈实现队列的头部出队，尾部入队操作：1234567891011121314151617181920212223242526class Solution&amp;#123;public:    void push(int node) &amp;#123;        while(!stack2.empty())        &amp;#123;            stack1.push(stack2">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5433630-06758a7c1e061db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5433630-9f99003244f7c548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5433630-85fe57149b32b741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2019-09-04T13:53:32.000Z">
<<<<<<< HEAD
<meta property="article:modified_time" content="2019-10-30T14:19:53.768Z">
=======
<meta property="article:modified_time" content="2020-12-06T12:34:07.769Z">
>>>>>>> 7c1172c9875087286cd44bd62769ab39300c7202
<meta property="article:author" content="Zheng Chu">
<meta property="article:tag" content="Cooking">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5433630-06758a7c1e061db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  <link rel="canonical" href="http://yoursite.com/2019/09/04/C++Cook/%E5%89%91%E6%8C%87offer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>剑指offer--c++ | Zheng Chu's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?<622a1a023f2bb8cdefcf61e3855bf317>";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zheng Chu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">让希望永驻</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-主页">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home  //"></i> <br>主页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-所有专栏">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th //"></i> <br>所有专栏</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-历史文章">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive //"></i> <br>历史文章</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-标签">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags  //"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-关于我">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user //"></i> <br>关于我</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    

  <a href="https://github.com/zhengchu1994" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/04/C++Cook/%E5%89%91%E6%8C%87offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Chu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/jojo3.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zheng Chu's Blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">剑指offer--c++

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-04 21:53:32" itemprop="dateCreated datePublished" datetime="2019-09-04T21:53:32+08:00">2019-09-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
<<<<<<< HEAD
                <time title="Modified: 2019-10-30 22:19:53" itemprop="dateModified" datetime="2019-10-30T22:19:53+08:00">2019-10-30</time>
=======
                <time title="Modified: 2020-12-06 20:34:07" itemprop="dateModified" datetime="2020-12-06T20:34:07+08:00">2020-12-06</time>
>>>>>>> 7c1172c9875087286cd44bd62769ab39300c7202
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h4><ol>
<li>用两个栈实现队列的头部出队，尾部入队操作：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.push(stack2.top());</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.push(stack1.top());</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol><a id="more"></a>
<p>30、包含min函数的栈</p>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为$O(1)$）。</p>
<ul>
<li>解题思路：复杂度是$O(1)$，则不是重装栈，trick是辅助栈进展方式为遇到最小就装它，否则装入当前栈顶元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        st1.push(value);</span><br><span class="line">        <span class="keyword">if</span>(st2.empty())</span><br><span class="line">            st2.push(value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = st2.top();</span><br><span class="line">            <span class="keyword">if</span>(top&gt;value)</span><br><span class="line">                st2.push(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st2.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st1.pop();</span><br><span class="line">        st2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st2.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>31、栈的压入和弹出</p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<ul>
<li>解：比较进栈数组中对每一个进栈的数与出栈数组的第一个元素，相等则对该元素出栈，继续比较进栈数组出栈后的栈顶与出栈数组第二个元素，相等则弹出，否则，继续进栈。若是最后进栈数组为空，则结果匹配正确。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.empty() &amp;&amp; popV.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pushV.empty() || popV.empty() || pushV.size()!=popV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;pushV.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(pushV[i]);</span><br><span class="line">            <span class="comment">//未越界且相等</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;popV.size() &amp;&amp; popV[j]==st.top())</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.empty()) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>59、队列最大的值</p>
<blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}</p>
</blockquote>
<p>1.直接算最大再排除第一个：这个算法总的时间复杂度是O(nk)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">if</span>(num.empty() || size == <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();  </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//记录滑动窗口大小是否达到</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            index.push_back(num[i]);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==size)</span><br><span class="line">            &#123;</span><br><span class="line">                count -= <span class="number">1</span>;</span><br><span class="line">                ans.push_back(*max_element(index.begin(), index.end()));</span><br><span class="line">                index.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.<br> 用双向队列实现，主要是理解思路。<br>从后删除的情况：只有当 当前数字比队列的后面数字大时。<br>从前删除的情况： 只有 当 队列前面的数字的序号不在滑动窗口内。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.size();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.size() &amp;&amp; num[s.back()]&lt;=num[i])<span class="comment">//从后面依次弹出队列中比当前num值小的元素，同时也能保证队列首元素为当前窗口最大值下标,同时排出多个</span></span><br><span class="line">                s.pop_back();</span><br><span class="line">            <span class="comment">//这里的while改为if也是可行的，因为只可能超出一个</span></span><br><span class="line">            <span class="keyword">while</span>(s.size() &amp;&amp; i-s.front()+<span class="number">1</span>&gt;size)<span class="comment">//当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span></span><br><span class="line">                s.pop_front();</span><br><span class="line">            s.push_back(i);<span class="comment">//把每次滑动的num下标加入队列</span></span><br><span class="line">            <span class="keyword">if</span>(size&amp;&amp;i+<span class="number">1</span>&gt;=size)<span class="comment">//当滑动窗口首地址i大于等于size时才开始写入窗口最大值</span></span><br><span class="line">                res.push_back(num[s.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组和数值"><a href="#数组和数值" class="headerlink" title="数组和数值"></a>数组和数值</h4><ol>
<li>下面代码的输出是什么</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">(<span class="keyword">int</span> data[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data1[]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line">    <span class="keyword">int</span> *data2 = data1;</span><br><span class="line">    <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line">    <span class="keyword">int</span> size3 = GetSize(data1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;size1 &lt;&lt; <span class="string">" "</span> &lt;&lt; size2 &lt;&lt; <span class="string">"  "</span> &lt;&lt; size3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">20</span> <span class="number">8</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>因为<code>sizeof(data1)</code>是求数组的大小，每个整数占4个字节；<br>第二个是因为指针占8个字节；<br>第三个是因为数组作为函数参数进行传递，数组退化为指针，也为8个字节。</p>
<ol>
<li>面试题：找出数组中任意一个重复的数字，数组满足：长度为n的数组里所有数字都在0~n-1的范围内。</li>
</ol>
<ul>
<li>思路：若不重复，每个下标对应一个等于下标值的数。对下标<code>i</code>与<code>m=arr[i]</code>作比较，不相等交换<code>arr[i]</code>与<code>arr[m]</code></li>
<li>时间复杂度$O(n)$，空间复杂度$O(1)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> &amp;answer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> ||i&gt;arr.size()<span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;arr.size();++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[i]!=i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]==arr[arr[i]])</span><br><span class="line">      &#123;</span><br><span class="line">        answer = arr[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        swap(arr[i], arr[arr[i]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> answer;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(duplicate(t, answer))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"one duplicate number is: "</span> &lt;&lt; answer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"no duplicate number ."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">one duplicate number is: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不修改数组找出重复的数字，数组满足：长度为n+1的数组里所有的数字都在1~n范围内，因此至少有一个数字是重复的。找出任意一个数字。</li>
</ol>
<ul>
<li>思路：辅助数组的方法$O(n)$时间复杂度，$O(n)$空间复杂度，空间换时间；折半查找的方法$O(n\lg n)$时间复杂度,$O(1)$空间复杂度，时间换空间。</li>
<li>排查数组哪一半的数字有重复，遍历数组所有数，计数每个数是否在下标范围，总计数值超过的这一半的大小的话，有重复元素；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">const</span> <span class="keyword">int</span> &amp;start,<span class="keyword">const</span> <span class="keyword">int</span> &amp;end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> iter:arr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;=iter &amp;&amp; iter&lt;=end)</span><br><span class="line">      ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start =<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> end = arr.size()<span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//直到二分数组大小为1为止</span></span><br><span class="line">  <span class="keyword">while</span>(end&gt;=start)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> middle=((end-start)&gt;&gt;<span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> count=countRage(arr, start, middle);</span><br><span class="line">    <span class="comment">//大小为1</span></span><br><span class="line">    <span class="keyword">if</span> (end==start)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//单个数字的计数是否重复</span></span><br><span class="line">      <span class="keyword">if</span>(count&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count &gt; middle-start+<span class="number">1</span>) <span class="comment">//是否在左侧</span></span><br><span class="line">      end = middle;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      start = middle+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> answer=getDuplication(t);</span><br><span class="line">  <span class="keyword">if</span>(answer&gt;=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"one duplicate number is: "</span> &lt;&lt; answer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"no duplicate number ."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index=numbers[i]%length;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index]&gt;=length)&#123;</span><br><span class="line">            *duplication=index;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;              </span><br><span class="line">        numbers[index]+=length;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>有规律的二维数组中找出某一个数：数组满足每行数大小递增，每一列大小递增。</li>
</ol>
<ul>
<li>从第一行最后一列排除：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//number 是要找的数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;mat,<span class="keyword">const</span> <span class="keyword">int</span> &amp;rows, <span class="keyword">const</span> <span class="keyword">int</span> &amp;columns, <span class="keyword">const</span> <span class="keyword">int</span> &amp;number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (rows&gt;<span class="number">0</span> &amp;&amp; columns&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>, column=columns<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(row&lt;rows &amp;&amp; column &gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(mat[row][column] == number)</span><br><span class="line">      &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(mat[row][column] &gt; number)</span><br><span class="line">        --column;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++row;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; test=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>&#125;,&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>&#125;,&#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">7</span>;</span><br><span class="line">  <span class="keyword">int</span> answer=Find(test,<span class="number">0</span>, <span class="number">4</span>, ans);</span><br><span class="line">  <span class="keyword">if</span>(answer&gt;=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find answer: "</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"no answer ."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>数值的整数次方：给定一个<code>double</code>类型的浮点数<code>base</code>和<code>int</code>类型的整数<code>exponent</code>。求<code>base</code>的<code>exponent</code>次方。</li>
</ol>
<ul>
<li>解：<br>利用了公式：</li>
</ul>
<script type="math/tex; mode=display">
a^n =
\begin{cases}
a^{n/2} * a^{n/2}, & n 为偶数\\
a^{(n-1)/2} * a^{(n-1)/2}*a, & n 为奇数
\end{cases}</script><p>实现的时候先对目标$target$的一半运算出来，然后判断是否是奇数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对数的绝对值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="built_in">abs</span>(exponent));</span><br><span class="line">        <span class="keyword">double</span> ans = _power(base, absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            ans = <span class="number">1.0</span>/ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//避免复杂度高，利用公式递归求解；</span></span><br><span class="line">    <span class="keyword">double</span> _power(<span class="keyword">int</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(absExponent==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(absExponent==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="comment">//递归公式</span></span><br><span class="line">        <span class="keyword">double</span> result=_power(base, absExponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//还剩一半的部分</span></span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="comment">//若为奇数值，乘上少乘的一个基底</span></span><br><span class="line">        <span class="keyword">if</span>(absExponent&amp;<span class="number">0x1</span> ==<span class="number">1</span>)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>调整数组顺序使得奇数位于偶数前面</li>
</ol>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<ul>
<li>解：<br><strong>相对位置不变—-&gt;保持稳定性；奇数位于前面，偶数位于后面 —-&gt;存在判断，挪动元素位置；</strong> 这些都和内部排序算法相似，考虑到具有稳定性的排序算法不多，例如插入排序，归并排序等；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">return</span> (n&amp;<span class="number">0x1</span>)==<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//stable_partition 这个函数函数功能是将数组中　isOk为真的放在数组前，假的放在数组后，和题意相符</span></span><br><span class="line">    <span class="comment">//stable_partition函数源码其实是开辟了新的空间，然后把符合条件的放在新空间的前面，其他的放在后面。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        stable_partition(<span class="built_in">array</span>.begin(),<span class="built_in">array</span>.end(),isOk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>29、顺时针打印矩阵</p>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<ul>
<li>解：需要分析它的边界：<br>打印四个边，什么时候退出：行、列数目大于2倍起点的时候；起点是每次的左上角位置；</li>
</ul>
<p>打印第一步：因为打印一圈至少有一步，所以直接打印；<br>打印第二步：行号大于起点行号才能多处行往下打印；<br>打印第三步：考虑这时候不能为一行一列的打印，至少是两行两列；<br>打印第四步：考虑已经少了一行数目；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> rows=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> cols=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//退出条件是两倍位置大小</span></span><br><span class="line">        <span class="keyword">while</span>(rows&gt; <span class="number">2</span>*position &amp;&amp; cols &gt; <span class="number">2</span>*position)</span><br><span class="line">        &#123;</span><br><span class="line">            print(matrix,position,rows,cols, ans);</span><br><span class="line">            ++position;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;mat,<span class="keyword">int</span> position, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rows = rows-position<span class="number">-1</span>;</span><br><span class="line">        cols = cols-position<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//case1:多余的列存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;=cols; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(mat[position][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//case2:多余的行存在</span></span><br><span class="line">        <span class="keyword">if</span>(position&lt;rows)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=position+<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(mat[i][cols]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//case3:从右到左打印;排除一行一列的打印</span></span><br><span class="line">        <span class="keyword">if</span>(position&lt;rows &amp;&amp; position&lt;cols)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cols<span class="number">-1</span>;i&gt;=position;--i)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(mat[rows][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//case4:从下到上打印</span></span><br><span class="line">        <span class="keyword">if</span>(position+<span class="number">1</span>&lt;rows &amp;&amp; position&lt;cols)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=rows<span class="number">-1</span>;i&gt;=position+<span class="number">1</span>;--i)</span><br><span class="line">                ans.push_back(mat[i][position]);</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>39、数组中出现次数超过一半的数字</p>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<ul>
<li>解：    两种方法实现：1,快排分割，元素被放置在中间位置，则找到结果；2.设置每次遇到的该数为result，并计数1，若下次遇到的<br>是该数，计数增加，若不是，计数减少，当计数为0，设result为新的该数字，最后被保存的result肯定是超过一半的数字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;numbers.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == result)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = numbers[i];</span><br><span class="line">                    count=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查该数组是否是满足题意的数组；</span></span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==result)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count*<span class="number">2</span>&lt;=numbers.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = numbers.size()&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(start, end, numbers);</span><br><span class="line">        <span class="keyword">while</span>(index!=middle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在下标小于中位数，它的middle应该在右边</span></span><br><span class="line">            <span class="keyword">if</span>(index&lt;middle)</span><br><span class="line">            &#123;</span><br><span class="line">                start = index+<span class="number">1</span>;</span><br><span class="line">                index = partition(start,end, numbers);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = index<span class="number">-1</span>;</span><br><span class="line">                index = partition(start, end, numbers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查是否有是合格的组数</span></span><br><span class="line">        <span class="keyword">int</span> result = numbers[index];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == result)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count*<span class="number">2</span>&lt;=numbers.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回元素的中间位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">size_t</span> position = start;<span class="comment">//记录哨兵最后放置的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot)<span class="comment">//只放置小的在左边就行</span></span><br><span class="line">            &#123;</span><br><span class="line">                position++;<span class="comment">//遇到一个小的元素，往前走一步做交换</span></span><br><span class="line">                <span class="keyword">if</span>(i!=position)<span class="comment">//头元素是povit，这个位置最后交换</span></span><br><span class="line">                    swap(arr[i], arr[position]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[position], arr[start]);</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>40、最小的k个数</p>
<blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<ul>
<li>解析：第一种一般可想到是堆排序，且不会修改输入数据，适合在处理海量数据中进行查找，STL中的<code>set</code>与<code>multiset</code>的底层是红黑树实现的，可以满足在$O(\lg n)$时间内完成查找、删除、插入。第二种方法是partition.</li>
</ul>
<p>方法1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=input.size();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span> || k&gt;len || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)<span class="comment">//先插入前main的k个后建立大顶堆</span></span><br><span class="line">            ans.push_back(input[i]);</span><br><span class="line">        <span class="comment">//建堆</span></span><br><span class="line">        make_heap(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;input.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i]&lt;ans[<span class="number">0</span>]) <span class="comment">//比堆顶元素还大，那么替换该元素放入ans，然后维持堆性质</span></span><br><span class="line">            &#123;</span><br><span class="line">                pop_heap(ans.begin(), ans.end()); <span class="comment">//最大元素放到末尾；</span></span><br><span class="line">                ans.pop_back();<span class="comment">//弹出最大的元素</span></span><br><span class="line">                ans.push_back(input[i]); </span><br><span class="line">                push_heap(ans.begin(), ans.end());<span class="comment">//维持堆性质</span></span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使其从小到大输出</span></span><br><span class="line">        sort_heap(ans.begin(),ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=input.size();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>||k&gt;len || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//仿函数中的greater&lt;T&gt;模板，从大到小排序</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; leastNums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vec_it=input.begin();</span><br><span class="line">        <span class="keyword">for</span>(;vec_it!=input.end();vec_it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将前k个元素插入集合</span></span><br><span class="line">            <span class="keyword">if</span>(leastNums.size()&lt;k)</span><br><span class="line">                leastNums.insert(*vec_it);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//第一个元素是最大值</span></span><br><span class="line">                <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator greatest_it=leastNums.begin();</span><br><span class="line">                <span class="comment">//如果后续元素&lt;第一个元素，删除第一个，加入当前元素</span></span><br><span class="line">                <span class="keyword">if</span>(*vec_it&lt;*(leastNums.begin()))</span><br><span class="line">                &#123;</span><br><span class="line">                    leastNums.erase(greatest_it);</span><br><span class="line">                    leastNums.insert(*vec_it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(leastNums.begin(),leastNums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>41、数据流中的中位数</p>
<blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<ul>
<li>解析：    假设整个数据容器分割为两部分，位于容器左边的部分比右边的部分小；容器左数组的最右边指向该部分最大的数；同样， 容器右数组的最左边指向该部分最小的数；<br>具体实现：左边用最大堆，右边用最小堆；首先保证数据平均分配到两个堆中，因此这两个堆中的数据数目之差不超过1，用偶数的数字都插入最小堆；保证最大堆中的数都小于最小堆，当前插入数字小于最大堆堆顶元素，可以把该堆的堆顶元素排除，插入到最小堆，然后把该数字插入最大堆中.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//第0个元素先插入到min中，之后第1个元素插入到max中.若元素有5个，那么0,2,4被插入到min中，可以看到</span></span><br><span class="line">        <span class="comment">//若元素有6个,0,2，4，被插入到min中，1,3,5被插入到max中。</span></span><br><span class="line">        <span class="comment">//因此min只用的元素大于等于max</span></span><br><span class="line">        <span class="comment">//元素为奇数时，返回min的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(((min.size()+max.size())&amp;<span class="number">1</span>)==<span class="number">0</span>)<span class="comment">//偶数时 ，放入最小堆</span></span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">if</span>(max.size()&gt;<span class="number">0</span> &amp;&amp; num&lt;max[<span class="number">0</span>])</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">// push_heap (_First, _Last),要先在容器中加入数据，再调用push_heap ()</span></span><br><span class="line">                 max.push_back(num);<span class="comment">//先将元素压入容器</span></span><br><span class="line">                 push_heap(max.begin(),max.end(),less&lt;<span class="keyword">int</span>&gt;());<span class="comment">//调整最大堆</span></span><br><span class="line">                 num=max[<span class="number">0</span>];<span class="comment">//取出最大堆的最大值</span></span><br><span class="line">                 <span class="comment">//pop_heap(_First, _Last)，要先调用pop_heap()再在容器中删除数据</span></span><br><span class="line">                 pop_heap(max.begin(),max.end(),less&lt;<span class="keyword">int</span>&gt;());<span class="comment">//删除最大堆的最大值</span></span><br><span class="line">                 max.pop_back(); <span class="comment">//在容器中删除</span></span><br><span class="line">              &#125;</span><br><span class="line">              min.push_back(num);<span class="comment">//压入最小堆</span></span><br><span class="line">              push_heap(min.begin(),min.end(),greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//调整最小堆</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span><span class="comment">//奇数时候，放入最大堆</span></span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">if</span>(min.size()&gt;<span class="number">0</span> &amp;&amp; num&gt;min[<span class="number">0</span>])</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">// push_heap (_First, _Last),要先在容器中加入数据，再调用push_heap ()</span></span><br><span class="line">                 min.push_back(num);<span class="comment">//先压入最小堆</span></span><br><span class="line">                 push_heap(min.begin(),min.end(),greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//调整最小堆</span></span><br><span class="line">                 num=min[<span class="number">0</span>];<span class="comment">//得到最小堆的最小值（堆顶）</span></span><br><span class="line">                 <span class="comment">//pop_heap(_First, _Last)，要先调用pop_heap()再在容器中删除数据</span></span><br><span class="line">                 pop_heap(min.begin(),min.end(),greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//删除最小堆的最大值</span></span><br><span class="line">                 min.pop_back(); <span class="comment">//在容器中删除</span></span><br><span class="line">              &#125;</span><br><span class="line">              max.push_back(num);<span class="comment">//压入数字</span></span><br><span class="line">              push_heap(max.begin(),max.end(),less&lt;<span class="keyword">int</span>&gt;());<span class="comment">//调整最大堆</span></span><br><span class="line">           &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*获取中位数*/</span>      </span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size=min.size()+max.size();</span><br><span class="line">            <span class="keyword">if</span>(size&lt;=<span class="number">0</span>) <span class="comment">//没有元素，抛出异常</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//throw exception("No numbers are available");</span></span><br><span class="line">            <span class="keyword">if</span>((size&amp;<span class="number">1</span>)==<span class="number">0</span>)<span class="comment">//偶数时，去平均</span></span><br><span class="line">                <span class="keyword">return</span> ((<span class="keyword">double</span>)(max[<span class="number">0</span>]+min[<span class="number">0</span>])/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//奇数，去最小堆，因为最小堆数据保持和最大堆一样多，或者比最大堆多1个</span></span><br><span class="line">                <span class="keyword">return</span> min[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>42、连续子数组的最大和</p>
<blockquote>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<ul>
<li>解析：1。动态规划问题，设在位置$n-1$处结尾的数组最大和为$f(n-1)$,那前面长度为$n$的数组的最大连续子序列的和为：</li>
</ul>
<script type="math/tex; mode=display">
f(n)=
\begin{cases}
data(n), & n=0 \bigcup f(n-1) < 0 \\
f(n-1) + data(n), & n \neq 0 \bigvee f(n-1) >0
\end{cases}</script><p>可以理解，如果前面的结尾的子串为负数，可以不加；若为正数，可以考虑加上这个值。最后还需要求 $max_{(i=1,2,3,….,N)}f(i)$ 找出最大的和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp = max&#123;f(i)&#125;,i=0,1,...,N</span></span><br><span class="line"><span class="comment">    f(i) = f(i-1) + data[i] if (i！= 0 &amp;&amp; f(i-1)&gt;0) else data[i].</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">           ans = max(ans, dp(i,arr,<span class="built_in">array</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//position给出结尾的位置</span></span><br><span class="line">    <span class="comment">//position结尾的最大和存入arr</span></span><br><span class="line">    <span class="comment">//target是原来的数组，用来查看当前的结尾数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> position,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &amp;&amp; arr[position<span class="number">-1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = target[position] + arr[position<span class="number">-1</span>];</span><br><span class="line">            arr.push_back(ans);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr.push_back(target[position]);</span><br><span class="line">            <span class="keyword">return</span> target[position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.跟据求和的性质，若为负，丢弃当前和，并记录每一的最大和；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            InvalidInput = <span class="literal">true</span>;<span class="comment">//判断是否无效输入而非最大和为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nCurSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> great =<span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nCurSum&lt;=<span class="number">0</span>) <span class="comment">//若为0或负值，那么略去这个求和，设新的求和为当前数</span></span><br><span class="line">                nCurSum=<span class="built_in">array</span>[i]; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nCurSum+=<span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(nCurSum&gt;great)<span class="comment">//记录最大子数组和</span></span><br><span class="line">                great = nCurSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> great;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> InvalidInput = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>43、1~n整数中1出现的次数</p>
<blockquote>
<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
</blockquote>
<ul>
<li>解析：    方法1:nlog(n)暴力搜索，对每一个数求一个计数1的函数；<br>方法2:log(n) 考虑问题本身的性质；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：nlog(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法1:nlog(n)暴力搜索，对每一个数求一个计数1的函数；</span></span><br><span class="line"><span class="comment">    方法2:log(n) 考虑问题本身的性质；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            number += Numberi(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Numberi</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">                number+=<span class="number">1</span>;</span><br><span class="line">            i=i/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法2：参考第三题：<a href="https://www.jianshu.com/p/1582fbaf05f7" target="_blank" rel="noopener">https://www.jianshu.com/p/1582fbaf05f7</a></p>
<blockquote>
<p>当 N 为 1 位数时，对于 N&gt;=1，1 的个数 f(N) 为1。<br>当 N 为 2 位数时，则个位上1的个数不仅与个位数有关，还和十位数字有关。<br>比如当 N=23 时，个位上 1 的个数有 1、11、21 共3个，十位上1的个数为10，11…19 共10个，所以 1 的个数 f(N) = 3+10 = 13。<br>看出来有规律一：<br>如果 N 的个位数 &gt;=1，则个位出现1的次数为十位数的数字加1；如果 N 的个位数为0，则个位出现 1 的次数等于十位数的数字。<br>十位数上出现1的次数类似，如果N的十位数字等于1，则十位数上出现1的次数为各位数字加1；如果N的十位数字大于1，则十位数上出现1的次数为10。<br>当 N 为 3 位数时，同样分析可得1的个数。如 N=123，可得 1出现次数 = 13+20+24 = 57。当 N 为 4,5…K 位数时，</p>
</blockquote>
<p>我们假设 N=abcde，则要计算百位上出现1的数目，则它受到三个因素影响：百位上的数字，百位以下的数字，百位以上的数字。<br>如果百位上数字为0，则百位上出现1的次数为更高位数字决定。如 N=12013，则百位出现1的数字有100~199， 1000~1199， 2100~2199…11100~111999 共 1200 个，等于百位的更高位数字(12)<em>当前位数(100)。<br>如果百位上数字为1，则百位上出现1的次数不仅受更高位影响，还受低位影响。如12113，则百位出现1的情况共有 1200+114=1314 个，也就是高位影响的 12 </em> 100 + 低位影响的 113+1 = 114 个。<br>如果百位上数字为其他数字，则百位上出现1的次数仅由更高位决定。如 12213，则百位出现1的情况为 (12+1)*100=1300。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>N=12013</th>
<th>i 是百位为0，高位是12现在从低位走到高位，即1~12013中，百位出现的1的数如下：</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>100~199</td>
</tr>
<tr>
<td>2</td>
<td>1100~1199</td>
</tr>
<tr>
<td>3</td>
<td>2100~1299</td>
</tr>
<tr>
<td>..</td>
<td>………..</td>
</tr>
<tr>
<td>10</td>
<td>9100~9199</td>
</tr>
<tr>
<td>11</td>
<td>10100~10199</td>
</tr>
<tr>
<td>12</td>
<td>11100~11199</td>
</tr>
</tbody>
</table>
</div>
<p>总共有12<em>100个1出现在百位。结论是位数为0时，只受高位数的影响，为高位数的值 </em> 当前位 。其他位的分析类似。</p>
<p>有以上分析思路，写出下面的代码。其中 low 表示低位数字，curr 表示当前考虑位的数字，high 表示高位数字。一个简单的分析，考虑数字 123，则首先考虑个位，则 curr 为 3，低位为 0，高位为 12；然后考虑十位，此时 curr 为 2，低位为 3，高位为 1。其他的数字可以以此类推，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//1的个数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//乘积因子</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>,after = <span class="number">0</span>,before = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((n/i)!= <span class="number">0</span>)&#123;           </span><br><span class="line">            current = (n/i)%<span class="number">10</span>; <span class="comment">//当前位数字</span></span><br><span class="line">            before = n/(i*<span class="number">10</span>); <span class="comment">//高位数字</span></span><br><span class="line">            after = n-(n/i)*i; <span class="comment">//低位数字</span></span><br><span class="line">            <span class="comment">//如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>)</span><br><span class="line">                count += before*i;</span><br><span class="line">            <span class="comment">//如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current == <span class="number">1</span>)</span><br><span class="line">                count += before * i + after + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count += (before + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">//前移一位</span></span><br><span class="line">            i = i*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>45、把数组排成最小的数</p>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<ul>
<li>解析：数组内的数变为string之后做拼接，按照字符串排序便可，拼接之后字符串AB&gt;BA，那么有B&lt;A,应该把B排前面。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//数组内的数变为string之后做拼接排序</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">int</span>(numbers.size());++i) ans+=to_string(numbers[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> sa=to_string(a), sb =to_string(b);</span><br><span class="line">        <span class="keyword">return</span> sa +sb &lt; sb + sa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>做法2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写的比较骚气的整型到string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">itos</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">9</span> ? itos(x / <span class="number">10</span>) : <span class="string">""</span>) + <span class="keyword">char</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较字符函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> itos(a) + itos(b) &lt; itos(b) + itos(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">        sort(a.begin(), a.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//转为字符再追加到s</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(a.size()); ++i) s += itos(a[i]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>49、第N个丑数。</p>
<blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<ul>
<li>解析：<br>空间换时间，记录存储下丑数，丑数按递增大小寻找；<br> 当前的丑数已经被找到,那么该丑数之前的数字都是排好序的，<br> 下一个丑数也是2、3、5的倍数，且大于当前丑数；找到每一个2、3、5倍数里最小的作为下一个丑数<br> 排序好的丑数中，前面的丑数是后面选出的丑数的因子之一，用下标跟随前面的因子与2、3、5的乘积&gt;大于当前丑数<br> 丑数定义：1是最小的丑数，只能被2或者3或者5整除的数是丑数;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyVec=&#123;<span class="number">1</span>&#125;; </span><br><span class="line">        <span class="comment">//作为下标记录2、3、5因子里前面</span></span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>, index3=<span class="number">0</span>, index5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyVec.size()&lt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            uglyVec.push_back(min(uglyVec[index2]*<span class="number">2</span>, min(uglyVec[index3]*<span class="number">3</span>, uglyVec[index5]*<span class="number">5</span>)));</span><br><span class="line">            <span class="keyword">if</span>(uglyVec[index2]*<span class="number">2</span>== uglyVec.back()) <span class="comment">//等号的意义是丑数不重复</span></span><br><span class="line">                index2++;</span><br><span class="line">            <span class="keyword">if</span>(uglyVec[index3]*<span class="number">3</span> == uglyVec.back())</span><br><span class="line">                index3++;</span><br><span class="line">            <span class="keyword">if</span>(uglyVec[index5]*<span class="number">5</span>== uglyVec.back())</span><br><span class="line">                index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglyVec.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>51、逆序对</p>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
</blockquote>
<ul>
<li>解析：</li>
</ul>
<p><code>/*归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，</code></p>
<p><code>合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面</code></p>
<p><code>数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i</code></p>
<p><code>参考剑指Offer，但是感觉剑指Offer归并过程少了一步拷贝过程。</code></p>
<p><code>还有就是测试用例输出结果比较大，对每次返回的count mod(1000000007)求余</code></p>
<p><code>*/</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*参考《剑指offer》，有两种思路。第一就是暴力求解法，时间复杂度为o（n^2）,空间复杂度o(1)</span></span><br><span class="line"><span class="comment">第二种思路就是使用归并排序的思想进行处理，时间复杂度o(nlog(n)),空间复杂度0（n）*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果少于等于1个元素，直接返回0</span></span><br><span class="line">        <span class="keyword">int</span>* copy=<span class="keyword">new</span> <span class="keyword">int</span>[data.size()];</span><br><span class="line">        <span class="comment">//初始化该数组，该数组作为存放临时排序的结果，最后要将排序的结果复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.size();i++)</span><br><span class="line">            copy[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//调用递归函数求解结果</span></span><br><span class="line">        <span class="keyword">int</span> count=InversePairCore(data,copy,<span class="number">0</span>,data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">delete</span>[] copy;<span class="comment">//删除临时数组</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//程序的主体函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="keyword">int</span>*&amp; copy,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[start]=data[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组拆分成两部分</span></span><br><span class="line">        <span class="keyword">int</span> length=(end-start)/<span class="number">2</span>;<span class="comment">//这里使用的下标法，下面要用来计算逆序个数；也可以直接使用mid=（start+end）/2</span></span><br><span class="line">        <span class="comment">//分别计算左边部分和右边部分</span></span><br><span class="line">        <span class="keyword">int</span> left=InversePairCore(data,copy,start,start+length)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span> right=InversePairCore(data,copy,start+length+<span class="number">1</span>,end)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="comment">//进行逆序计算</span></span><br><span class="line">        <span class="keyword">int</span> i=start+length;<span class="comment">//前一个数组的最后一个下标</span></span><br><span class="line">        <span class="keyword">int</span> j=end;<span class="comment">//后一个数组的下标</span></span><br><span class="line">        <span class="keyword">int</span> index=end;<span class="comment">//辅助数组下标，从最后一个算起</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start &amp;&amp; j&gt;=start+length+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                copy[index--]=data[i--];</span><br><span class="line">                <span class="comment">//统计长度</span></span><br><span class="line">                count+=j-start-length;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">1000000007</span>)<span class="comment">//数值过大求余</span></span><br><span class="line">                    count%=<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy[index--]=data[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=start;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[index--]=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=start+length+<span class="number">1</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[index--]=data[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;</span><br><span class="line">            data[i] = copy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回最终的结果</span></span><br><span class="line">        <span class="keyword">return</span> (count+left+right)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>56、数组中数字出现的次数</p>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度$O(1)$,空间复杂度$O(n)$.</p>
</blockquote>
<ul>
<li>解析：</li>
</ul>
<p>61、扑克牌顺子</p>
<blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0</p>
</blockquote>
<ul>
<li>解析：/先计算0，然后去掉0的部分，遍历这个数组，看相等的时候直接返回0,不连续的时候，累加间隔大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        <span class="keyword">int</span> countZero=<span class="number">0</span>,unequal=<span class="number">0</span>; <span class="comment">//计数0的个数，计算不等数字的间隔</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size() &amp;&amp; numbers[i]==<span class="number">0</span>;++i)</span><br><span class="line">            countZero++;</span><br><span class="line">        <span class="comment">//先计算出0的个数，这些0不在我们的规则内；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=countZero+<span class="number">1</span>; i&lt;numbers.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i<span class="number">-1</span>]+<span class="number">1</span> != numbers[i])</span><br><span class="line">                unequal= unequal + numbers[i] - numbers[i<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(unequal&gt;countZero)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>62、约斯夫环</p>
<blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<ul>
<li>: 约瑟夫环两种解法，1循环链表，2是找规律直接算出结果；<br>1.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n;++i)</span><br><span class="line">            numbers.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = numbers.begin();</span><br><span class="line">        <span class="keyword">while</span>(numbers.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先游走m步，这里的i=1，因为删除第m个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                iter++;</span><br><span class="line">                <span class="keyword">if</span>(iter==numbers.end())</span><br><span class="line">                    iter = numbers.begin();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查看是否是迭代器最后一个位置</span></span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next=++iter;</span><br><span class="line">            <span class="keyword">if</span>(next==numbers.end()) next = numbers.begin();</span><br><span class="line">            --iter;</span><br><span class="line">            numbers.erase(iter);</span><br><span class="line">            iter = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>66、乘积数组</p>
<blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
</blockquote>
<ul>
<li>解析：分析递归式如图：<br>剑指的思路：</li>
</ul>
<p><strong>B[i]的值可以看作下图的矩阵中每行的乘积。</strong></p>
<p>下三角用连乘可以很容求得，上三角，从下向上也是连乘。</p>
<p>因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5433630-06758a7c1e061db4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="841505_1472459965615_8640A8F86FB2AB3117629E2456D8C652.jpg"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</span></span><br><span class="line"><span class="comment">//从左到右算 B[i]=A[0]*A[1]*...*A[i-1]</span></span><br><span class="line"><span class="comment">//从右到左算B[i]*=A[i+1]*...*A[n-1]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(n);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;ret*=A[i++])&#123;</span><br><span class="line">            b[i]=ret;</span><br><span class="line">        &#125;</span><br><span class="line">        ret=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;ret*=A[i--])&#123;</span><br><span class="line">            b[i]*=ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>64、</p>
<blockquote>
</blockquote>
<ul>
<li>利用短路原理：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        ans &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>65、不用加减乘除法做加法</p>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<ul>
<li>分析：考虑位运算，先相加，不进位，对进位的位置再做相加。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, carry;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = num1 ^ num2; <span class="comment">// 异或运算：0+1、1+0都是1，其他都是0；</span></span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>; <span class="comment">//与运算，只有1+1才为1，然后左移1位；</span></span><br><span class="line">            num1 = sum;    <span class="comment">// 第三部求和是一个循环过程，直到没有进位，也就是num2为0</span></span><br><span class="line">            num2 = carry;  <span class="comment">// 下一次循环中更新sum</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="94-二叉树的非递归前序遍历"><a href="#94-二叉树的非递归前序遍历" class="headerlink" title="94. 二叉树的非递归前序遍历"></a>94. 二叉树的非递归前序遍历</h4><ol>
<li><p>直接进出入栈，拿出数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *top = st.top();</span><br><span class="line">            ans.push_back(top-&gt;val);</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right)</span><br><span class="line">                st.push(top-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left)</span><br><span class="line">                st.push(top-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="94-二叉树的非递归中序遍历"><a href="#94-二叉树的非递归中序遍历" class="headerlink" title="94. 二叉树的非递归中序遍历"></a>94. 二叉树的非递归中序遍历</h4></li>
<li><p>首先是根非空入栈，对子树最左边节点一直进栈；<br>直到左为空，重置根为栈顶节点，取出数据并出栈；<br>重置根为根的右边节点；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;think:首先是根入栈，左边不为空则进栈，直到左为空出栈，然后右边不为空进栈</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        std::stack&lt;TreeNode *&gt; Stack;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        while(root || !Stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if (root !&#x3D; nullptr)</span><br><span class="line">                Stack.push(root);</span><br><span class="line">            while(root &amp;&amp; root-&gt;left !&#x3D; nullptr) &#x2F;&#x2F;先验证根是否存在；再验证左节点</span><br><span class="line">            &#123;</span><br><span class="line">                Stack.push(root-&gt;left);</span><br><span class="line">                root &#x3D; root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; Stack.top();</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            Stack.pop();</span><br><span class="line">            root &#x3D; root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="145-二叉树的非递归后序遍历"><a href="#145-二叉树的非递归后序遍历" class="headerlink" title="145. 二叉树的非递归后序遍历"></a>145. 二叉树的非递归后序遍历</h4><ul>
<li>跟前序遍历很像：第一次访问根节点，用于确定是否还有属于它的子节点需要进栈，若有就进栈，这是第一次遍历该节点；<br>不同的是：在第二次遍历时出栈。栈顶pop一个新的节点时，是第二次遍历，第二次遍历时出栈。</li>
</ul>
<ol>
<li>进两次栈的方法：</li>
</ol>
<ul>
<li>初始化：根非空进栈两次；</li>
<li>循环：栈非空的话：<pre><code> * 设置当前出栈元素cur，栈顶出栈；（第一次遍历）
  *  当前出栈元素等于栈顶元素（确保为第一次遍历）的话：若右非空，进栈两次，若左非空，进栈两次；否则的话（第二次遍历）：取出当前cur的值
</code></pre></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;     </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; Stack;</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        Stack.push(root);</span><br><span class="line">        Stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!Stack.empty())</span><br><span class="line">        &#123;  </span><br><span class="line">            cur = Stack.top();</span><br><span class="line">            Stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(!Stack.empty() &amp;&amp; cur==Stack.top()) <span class="comment">//因为之前出栈，先看是否为空，然后确定目前的栈顶部节点是否访问过，如果cur与栈顶不一样，则已经访问过一次，目前这个可以出栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) <span class="comment">//后序遍历先进右</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Stack.push(cur-&gt;right);</span><br><span class="line">                    Stack.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left)<span class="comment">//后进左、后进先出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Stack.push(cur-&gt;left);</span><br><span class="line">                    Stack.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(cur-&gt;val);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>考虑根节点与栈顶节点，</li>
</ol>
<ul>
<li>循环：若<code>root</code>非空或者栈非空：<pre><code>* 若根非空，进栈，设置根为根的左节点；
* 一直入栈最左的子节点（作为新根节点），直到根为空；
* 设置一个节点记录栈顶节点，若记录节点top有右节点，且最后出栈的节点不等于记录节点或栈顶节点，根节点重置为栈顶节点的右边节点；
* 否则栈顶节点无右节点，取值，出栈，重置最后出栈的节点；
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;     </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; Stack;</span><br><span class="line">        TreeNode *last=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root || !Stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                Stack.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                TreeNode* top = Stack.top();</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;right &amp;&amp; last!=top-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = top-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(top-&gt;val);</span><br><span class="line">                    last = top;</span><br><span class="line">                    Stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>用前序遍历，最后反转数组；<br>pre-order traversal is root-left-right, and post order is left-right-root. modify the code for pre-order to make it root-right-left, and then reverse the output so that we can get left-right-root <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;     </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; Stack;</span><br><span class="line">        TreeNode *tmp;</span><br><span class="line">        Stack.push(root);</span><br><span class="line">        <span class="comment">//前左右；左右前=前右左的反转</span></span><br><span class="line">        <span class="keyword">while</span>(!Stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = Stack.top();</span><br><span class="line">            ans.push_back(tmp-&gt;val);</span><br><span class="line">            Stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                Stack.push(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                Stack.push(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rans(ans.rbegin(), ans.rend());</span><br><span class="line">        <span class="keyword">return</span> rans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h4><ul>
<li><p>主要是根节点大于所有的左子树，小于所有的右子树；怎么样把这个根部的节点信息传递下去。</p>
</li>
<li><p>方法1：递归，除了比较根与左右节点，还要比较左右节点与上一次的根节点值是否满足大小关系；<br>用min判断传入为（当前根节点的）左节点时，比较右节点是否小于上一次根节点值；<br>用max判断传入为（当前根节点的）右节点时，比较左节点是否大于上一次根节点值；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Thinking: 全部的子树上的节点都必须大于或者小于根节点才行</span></span><br><span class="line">    <span class="comment">//传入子树递归的时候带上根节点的值，进行比较</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isValidBST(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> _isValidBST(TreeNode *root,<span class="keyword">long</span> min, <span class="keyword">long</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=min || root-&gt;val&gt;=max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (_isValidBST(root-&gt;left,min,root-&gt;val) &amp;&amp; _isValidBST(root-&gt;right,root-&gt;val,max));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-重建二叉树：根据前序和中序遍历的结果重建二叉树。假设输入的遍历结果都不含有重复的数字。"><a href="#1-重建二叉树：根据前序和中序遍历的结果重建二叉树。假设输入的遍历结果都不含有重复的数字。" class="headerlink" title="1. 重建二叉树：根据前序和中序遍历的结果重建二叉树。假设输入的遍历结果都不含有重复的数字。"></a>1. 重建二叉树：根据前序和中序遍历的结果重建二叉树。假设输入的遍历结果都不含有重复的数字。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> * Definition <span class="keyword">for</span> binary tree</span><br><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.size() == <span class="number">0</span>)&#123;                    <span class="comment">//如果为空，返回NULL</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次是前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_pre, right_pre, left_vin, right_vin;</span><br><span class="line">        <span class="comment">//前序遍历第一个节点一定为根节点</span></span><br><span class="line">        TreeNode* head = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//找到中序遍历的根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历找到中序遍历根节点索引值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == vin[i])&#123;</span><br><span class="line">                root = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">//利用中序遍历的根节点，对二叉树节点进行归并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root; i++)&#123;</span><br><span class="line">            left_vin.push_back(vin[i]);</span><br><span class="line">            left_pre.push_back(pre[i + <span class="number">1</span>]);            <span class="comment">//前序遍历第一个为根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = root + <span class="number">1</span>; i &lt; pre.size(); i++)&#123;</span><br><span class="line">            right_vin.push_back(vin[i]);</span><br><span class="line">            right_pre.push_back(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></span><br><span class="line">        head-&gt;left = reConstructBinaryTree(left_pre, left_vin);</span><br><span class="line">        head-&gt;right = reConstructBinaryTree(right_pre, right_vin);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉树的下一个节点：给定一颗二叉树和其中的一个节点，如何找到中序遍历序列的下一个节点，每个节点左右子节点指针，还有指向父节点的指针。"><a href="#2-二叉树的下一个节点：给定一颗二叉树和其中的一个节点，如何找到中序遍历序列的下一个节点，每个节点左右子节点指针，还有指向父节点的指针。" class="headerlink" title="2. 二叉树的下一个节点：给定一颗二叉树和其中的一个节点，如何找到中序遍历序列的下一个节点，每个节点左右子节点指针，还有指向父节点的指针。"></a>2. 二叉树的下一个节点：给定一颗二叉树和其中的一个节点，如何找到中序遍历序列的下一个节点，每个节点左右子节点指针，还有指向父节点的指针。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *right;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *next;</span></span><br><span class="line"><span class="comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pNode) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeLinkNode* pNext=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//该节点存在右子树，返回右子树的最左叶节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pNext = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(pNext-&gt;left)</span><br><span class="line">                pNext=pNext-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> pNext;</span><br><span class="line">         <span class="comment">//该节点无右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeLinkNode* pCurrent=pNode;</span><br><span class="line">            TreeLinkNode* pParent=pNode-&gt;next;</span><br><span class="line">            <span class="comment">//是否是某父节点的左节点;不是的情况且该节点是某父节点的右子节点，向上递归，直到为某一个父节点的左子节点</span></span><br><span class="line">            <span class="keyword">while</span>(pParent!=<span class="literal">nullptr</span> &amp;&amp; pCurrent==pParent-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                pCurrent = pParent;</span><br><span class="line">                pParent = pCurrent-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNext = pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h4><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//非空情况</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot1!=<span class="literal">nullptr</span> &amp;&amp; pRoot2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val==pRoot2-&gt;val)</span><br><span class="line">                result=DoesTree1HaveTree2(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)<span class="comment">//左右子树上递归</span></span><br><span class="line">                result=HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode* pRoot1,TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2==<span class="literal">nullptr</span>)<span class="comment">//递归完成返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span>)<span class="comment">//未匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val!=pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> DoesTree1HaveTree2(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; DoesTree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h4><blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
</blockquote>
<ul>
<li>思路就是左右都是空，就不用管了；而只有一个子节点为空，另一个不为空，也必须交换才行；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span>; <span class="comment">//Empty tree</span></span><br><span class="line">        <span class="comment">//leaf node already shifted</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;left==<span class="literal">nullptr</span> &amp;&amp; pRoot-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//whatever empty , both child nodes do shift</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pRoot;</span><br><span class="line">        TreeNode* tmp=pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left=pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right=tmp;</span><br><span class="line">        <span class="comment">//recursion</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right!=<span class="literal">nullptr</span>) </span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h4><blockquote>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<ul>
<li>解题思路：特例：树上的节点值相同的时候还需要比较空节点位置是否对称；<br>对称的例子如：<blockquote>
<p>  8<br>   6     6<br>  5 7 7 5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot,pRoot);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* p1, TreeNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">nullptr</span> &amp;&amp; p2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">nullptr</span> || p2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(p1-&gt;left,p2-&gt;right) &amp;&amp; isSymmetrical(p1-&gt;right, p2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="32、从下到上打印二叉树"><a href="#32、从下到上打印二叉树" class="headerlink" title="32、从下到上打印二叉树"></a>32、从下到上打印二叉树</h4><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<ul>
<li>解：层次遍历用队列存储即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(que.front()-&gt;val);</span><br><span class="line">            TreeNode* top=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;left)</span><br><span class="line">                que.push(top-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(top-&gt;right)</span><br><span class="line">                que.push(top-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="32-2、分行从上到下打印二叉树"><a href="#32-2、分行从上到下打印二叉树" class="headerlink" title="32.2、分行从上到下打印二叉树"></a>32.2、分行从上到下打印二叉树</h4><blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<ul>
<li>解：需要记录当前层中还没有打印的节点数、下一层节点的数目；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">            <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">            que.push(pRoot);</span><br><span class="line">            <span class="keyword">int</span> nextNodeNum=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!que.empty())</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _ans;</span><br><span class="line">                <span class="keyword">int</span> curNodeNum=nextNodeNum;<span class="comment">//当前层的数目为1，下一层的数目节点为0</span></span><br><span class="line">                nextNodeNum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(curNodeNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* top=que.front();</span><br><span class="line">                    _ans.push_back(top-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(top-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.push(top-&gt;left);</span><br><span class="line">                        nextNodeNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(top-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.push(top-&gt;right);</span><br><span class="line">                        nextNodeNum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.pop();</span><br><span class="line">                    --curNodeNum;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(_ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="33、二叉搜索树的后序遍历序列"><a href="#33、二叉搜索树的后序遍历序列" class="headerlink" title="33、二叉搜索树的后序遍历序列"></a>33、二叉搜索树的后序遍历序列</h4><blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<ul>
<li>解析：最末的位置存储的是根节点，然后左右子树的边界通过循环可以找到，进一步判断右子树是否都小于根节点，如果满足，下一步看左右子树若存在，左右子树是否递归满足。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Help(sequence, sequence.size());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Help</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sequence, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">    Params:size represents the root node position.</span></span></span><br><span class="line"><span class="function"><span class="comment">    */</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找寻左右子树分界节点</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;size<span class="number">-1</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;sequence[size<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//右子树是否满足大于根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;size;++j)</span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;sequence[size<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//递归判断左子树</span></span><br><span class="line">        <span class="keyword">bool</span> left=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)<span class="comment">//存在左子树才行</span></span><br><span class="line">            left = Help(sequence, i);</span><br><span class="line">        <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;size<span class="number">-1</span>)</span><br><span class="line">            right=Help(sequence, size<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="34、二叉树中和为某一值的路径"><a href="#34、二叉树中和为某一值的路径" class="headerlink" title="34、二叉树中和为某一值的路径"></a>34、二叉树中和为某一值的路径</h4><blockquote>
<p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
</blockquote>
<ul>
<li>解析：<br>方法1. 递归、判断成功的时候把成功的路径压入结果ans；但是每次递归path需要重新拷贝使用；<br>方法2. </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        _FindPath(root,expectNumber,path,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//path不能用引用，递归的时候需要拷贝path</span></span><br><span class="line">    <span class="keyword">void</span> _FindPath(TreeNode* root,<span class="keyword">int</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(num==root-&gt;val &amp;&amp; (!root-&gt;left) &amp;&amp; (!root-&gt;right))</span><br><span class="line">            &#123;    </span><br><span class="line">                ans.push_back(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _FindPath(root-&gt;left,num - root-&gt;val, path, ans);</span><br><span class="line">            _FindPath(root-&gt;right,num - root-&gt;val, path, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="36、二叉搜索树与双向链表"><a href="#36、二叉搜索树与双向链表" class="headerlink" title="36、二叉搜索树与双向链表"></a>36、二叉搜索树与双向链表</h4><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<ul>
<li>递归，根节点进入，然后向左递归，出来之后，若有右节点，向右走，走到none在指向root，root在指向它；右子树也一样这样。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        pRootOfTree=ConvertNode(pRootOfTree);</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left) pRootOfTree=pRootOfTree-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回子树的根节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">ConvertNode</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            TreeNode* left = ConvertNode(pRootOfTree-&gt;left);</span><br><span class="line">            <span class="comment">//左子树的根节点往右走、它的下一个节点是当前的根节点</span></span><br><span class="line">            <span class="keyword">while</span>(left-&gt;right) left=left-&gt;right;</span><br><span class="line">            left-&gt;right=pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left=left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* right = ConvertNode(pRootOfTree-&gt;right);</span><br><span class="line">            <span class="comment">//右子树的根节点往左走、它的上一个节点是目前的根节点；</span></span><br><span class="line">            <span class="keyword">while</span>(right-&gt;left) right=right-&gt;left;</span><br><span class="line">            right-&gt;left=pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;right=right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h4><blockquote>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。<br>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
</blockquote>
<ul>
<li>不太熟悉char的这些操作，看别人的答案，非得搞指针传入的默认函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> r = to_string(root-&gt;val);</span><br><span class="line">        r.push_back(<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">char</span> *left = Serialize(root-&gt;left);</span><br><span class="line">        <span class="keyword">char</span> *right = Serialize(root-&gt;right);</span><br><span class="line">        <span class="keyword">char</span> *ret = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(left) + <span class="built_in">strlen</span>(right) + r.size()];</span><br><span class="line">        <span class="built_in">strcpy</span>(ret, r.c_str());</span><br><span class="line">        <span class="built_in">strcat</span>(ret, left);</span><br><span class="line">        <span class="built_in">strcat</span>(ret, right);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decode(str);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">decode</span><span class="params">(<span class="keyword">char</span>* &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*str != <span class="string">','</span>) <span class="comment">//每一个值都是char</span></span><br><span class="line">            num = num*<span class="number">10</span> + (*(str++)-<span class="string">'0'</span>);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="54、请找出其中的第k小的结点"><a href="#54、请找出其中的第k小的结点" class="headerlink" title="54、请找出其中的第k小的结点"></a>54、请找出其中的第k小的结点</h4><blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<ul>
<li>//思路：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。<br>//     所以，按照中序遍历顺序找到第k个结点就是结果。<br>1.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot== <span class="literal">nullptr</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> findKthNode(pRoot, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">findKthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* target = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            target = findKthNode(pRoot-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                target = pRoot;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="literal">nullptr</span> &amp;&amp; pRoot-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            target = findKthNode(pRoot-&gt;right, k);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node =  KthNode(pRoot-&gt;left, k);</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">nullptr</span>) </span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            index++;    <span class="comment">//中序遍历操作处</span></span><br><span class="line">            <span class="keyword">if</span>(index==k)</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            node = KthNode(pRoot-&gt;right, k);</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="55、输入一棵二叉树，求该树的深度。"><a href="#55、输入一棵二叉树，求该树的深度。" class="headerlink" title="55、输入一棵二叉树，求该树的深度。"></a>55、输入一棵二叉树，求该树的深度。</h4><blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//二叉树的深度为从根节点到叶节点的最长路径长度;</span></span><br><span class="line">    <span class="comment">//如果只有根节点，那么树的深度是1;</span></span><br><span class="line">    <span class="comment">//如果有左右子树，那么树的深度为左子树与右子树中最大的深度+1;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+ max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="55-2、输入一棵二叉树，判断该二叉树是否是平衡二叉树。"><a href="#55-2、输入一棵二叉树，判断该二叉树是否是平衡二叉树。" class="headerlink" title="55.2、输入一棵二叉树，判断该二叉树是否是平衡二叉树。"></a>55.2、输入一棵二叉树，判断该二叉树是否是平衡二叉树。</h4><blockquote>
<p>如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么他就是一颗平衡二叉树。</p>
</blockquote>
<ul>
<li>方法1：求节点的左右子树的深度，然后判断是否相差不大于1；<br>  方法2：由于方法1中重复的遍历了某些节点，因此我们选择后序遍历每一个节点，这样的话在遍历一个节点之前，<br>  已经遍历了它的左、右子树；遍历的同时记录节点深度；</li>
</ul>
<p>1.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法1：求节点的左右子树的深度，然后判断是否相差不大于1；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff&lt;<span class="number">-1</span> || diff&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>2.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法1：求节点的左右子树的深度，然后判断是否相差不大于1；</span></span><br><span class="line"><span class="comment">    方法2：由于方法1中重复的遍历了某些节点，因此我们选择后序遍历每一个节点，这样的话在遍历一个节点之前，</span></span><br><span class="line"><span class="comment">    已经遍历了它的左、右子树；遍历的同时记录节点深度；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced(pRoot, depth);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> &amp;depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            depth=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span>(IsBalanced(pRoot-&gt;left, left) &amp;&amp; IsBalanced(pRoot-&gt;right, right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = left - right;</span><br><span class="line">            <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth = <span class="number">1</span> + (left&gt;right ?left :right);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="按之字形打印树"><a href="#按之字形打印树" class="headerlink" title="按之字形打印树"></a>按之字形打印树</h4><blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<ul>
<li>1.队列+数组翻转来实现，偶数的时候翻转数组再添加；2.双栈实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;();</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>; <span class="comment">//偶数的时候翻转数组</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _ans;</span><br><span class="line">            <span class="keyword">int</span> size=que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i) <span class="comment">//打印完当前行的元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.front();</span><br><span class="line">                _ans.push_back(front-&gt;val);</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                    que.push(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                    que.push(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (even)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(_ans.begin(),_ans.end());</span><br><span class="line">            &#125;</span><br><span class="line">            even = !even;</span><br><span class="line">            ans.push_back(_ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h4><p>问路径上是否有简单路径和等于给定数值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//叶节点减为0才返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!(sum-root-&gt;val) &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> (hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h4><p>上一题的基础上，再加上返回所有满足这个要求的路径</p>
<ol>
<li>直接类似上题解法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; paths;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        findPaths(root, sum, path, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPaths</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span> (!(node -&gt; left) &amp;&amp; !(node -&gt; right) &amp;&amp; sum == node -&gt; val)</span><br><span class="line">            paths.push_back(path);</span><br><span class="line">        findPaths(node -&gt; left, sum - node -&gt; val, path, paths);</span><br><span class="line">        findPaths(node -&gt; right, sum - node -&gt; val, path, paths);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="1-斐波那契数列：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。"><a href="#1-斐波那契数列：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。" class="headerlink" title="1. 斐波那契数列：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。"></a>1. 斐波那契数列：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</h4><script type="math/tex; mode=display">
f(n)=\begin{cases}
  0, & n=0\\
  1, & n=1\\
  f(n-1) +f(n-2), & n>1
\end{cases}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> table[]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> table[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = table[<span class="number">0</span>] + table[<span class="number">1</span>];</span><br><span class="line">            table[<span class="number">0</span>] = table[<span class="number">1</span>];</span><br><span class="line">            table[<span class="number">1</span>] =tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。"><a href="#2-跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。" class="headerlink" title="2. 跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。"></a>2. 跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两种情况：跳一步剩下（number-1）步；</span></span><br><span class="line">        <span class="comment">//跳两步剩下（number-2）步；</span></span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(number<span class="number">-1</span>) + jumpFloor(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目描述：我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<ul>
<li>解析：参考：<a href="https://www.nowcoder.com/questionTerminal/72a5a919508a4251859fb2cfb987a0e6?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/72a5a919508a4251859fb2cfb987a0e6?f=discussion</a></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5433630-9f99003244f7c548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;=<span class="number">2</span>) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">return</span> rectCover(number<span class="number">-1</span>) + rectCover(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="查找、排序"><a href="#查找、排序" class="headerlink" title="查找、排序"></a>查找、排序</h3><h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><ol>
<li><p>哈希表的主要优点是在$O(1)$时间内查找某一元素，是效率最高的查找方式；但是缺点是需要额外的空间来实现哈希表。</p>
</li>
<li><p>旋转数组的最小数字：</p>
</li>
</ol>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//头部和尾部位置，指向两个排序好的子数组</span></span><br><span class="line">        <span class="keyword">int</span> indexFirst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> indexLast = rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//若全部数都旋转一次，最小值为首元素</span></span><br><span class="line">        <span class="keyword">int</span> indexMiddle = indexFirst;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[indexFirst]&gt;=rotateArray[indexLast])</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//若相邻，那么右边索引在最小值处</span></span><br><span class="line">            <span class="keyword">if</span>(indexFirst+<span class="number">1</span> == indexLast)</span><br><span class="line">                <span class="keyword">return</span> rotateArray[indexLast];</span><br><span class="line">            </span><br><span class="line">            indexMiddle = (indexLast+indexFirst)/<span class="number">2</span>; </span><br><span class="line">            <span class="comment">//indexMiddle = (indexLast-indexFirst)/2 + indexFirst; </span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((rotateArray[indexFirst] == rotateArray[indexLast]) &amp;&amp; (rotateArray[indexLast]==rotateArray[indexMiddle]))</span><br><span class="line">                <span class="keyword">return</span> search(rotateArray,indexFirst,indexLast);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[indexMiddle]&gt;=rotateArray[indexFirst])</span><br><span class="line">            &#123;</span><br><span class="line">                indexFirst = indexMiddle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若不是右子数组最小的位置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[indexMiddle]&lt;=rotateArray[indexLast])</span><br><span class="line">                indexLast = indexMiddle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=arr[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>; i&lt;=right; ++i)</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;min) min=arr[i];</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="统计一个数字在排序数组中出现的次数。"><a href="#统计一个数字在排序数组中出现的次数。" class="headerlink" title="统计一个数字在排序数组中出现的次数。"></a>统计一个数字在排序数组中出现的次数。</h4><ul>
<li>因为data中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5 这两个数应该插入的位置，然后相减即可。只是取的距离k最近的值，由于都是整数，原数组中可能存在k-1或者k+1；而k+0.5和k-0.5之间保证只有数字k。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biSearch(data, k+<span class="number">0.5</span>) - biSearch(data, k<span class="number">-0.5</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">double</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>, end=data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data[mid]&lt;k)</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//start是这个端点</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="57、和为s的一对数"><a href="#57、和为s的一对数" class="headerlink" title="57、和为s的一对数"></a>57、和为s的一对数</h4><blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<ul>
<li>解析：    //假设：若b&gt;a,且存在，<br>  //a + b = s;<br>  //(a - m ) + (b + m) = s<br>  //则：(a- m)(b + m)=ab - (b-a)m - m*m &lt; ab；说明外层的乘积更小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//假设：若b&gt;a,且存在，</span></span><br><span class="line">    <span class="comment">//a + b = s;</span></span><br><span class="line">    <span class="comment">//(a - m ) + (b + m) = s</span></span><br><span class="line">    <span class="comment">//则：(a- m)(b + m)=ab - (b-a)m - m*m &lt; ab；说明外层的乘积更小</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first=<span class="built_in">array</span>.begin(); </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last=<span class="built_in">array</span>.end()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(first&lt;last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> fnum = *first, lnum=  *last;</span><br><span class="line">            <span class="keyword">if</span>(fnum+lnum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(fnum);</span><br><span class="line">                ans.push_back(lnum);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fnum + lnum &lt; sum)</span><br><span class="line">                first++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-和为连续整数的序列"><a href="#2-和为连续整数的序列" class="headerlink" title="2.和为连续整数的序列"></a>2.和为连续整数的序列</h4><blockquote>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
</blockquote>
<ul>
<li>解析：考虑用small和big分别表示序列的最小值和最大值，初始化，small=1与big=2，如果序列和大于sum，那么去掉最小的small也就是说更新small++；小于序列的话，增大big，同时把small到big的和curSum更新；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> small=<span class="number">1</span>, big=<span class="number">2</span>, mid=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum=small+big;</span><br><span class="line">        <span class="comment">//等于3的时候</span></span><br><span class="line">        <span class="keyword">if</span>(curSum==sum) </span><br><span class="line">            ans.push_back(initVec(small,big));</span><br><span class="line">        <span class="keyword">while</span>(small&lt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">//当前的和等于总和</span></span><br><span class="line">            <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(initVec(small,big));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前的和大于总和；最小的左边未超出中位数</span></span><br><span class="line">            <span class="keyword">while</span>(curSum&gt;sum &amp;&amp; small &lt;mid)</span><br><span class="line">            &#123;</span><br><span class="line">                curSum-=small;</span><br><span class="line">                small++;</span><br><span class="line">                <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">                    ans.push_back(initVec(small,big));</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//当前的和小于总和,再加入大一位的数，并填入总和内</span></span><br><span class="line">            big++;</span><br><span class="line">            curSum+=big;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; initVec(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;=last;++i)</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><ol>
<li>剪绳子：长度为$n$的绳子，剪成$m$段，各段长度记为$k[0],…,k[m]$,求各段最大乘积多少？$（n&gt;1,m&gt;1）$</li>
</ol>
<ul>
<li>dp：即$f(n)$为把长度$n$的绳子剪成若干段($[1,n-1]$)的最大乘积。</li>
<li>用子问题定义原问题：$f(n)= \max_{0&lt;i&lt;n}{f(i) * f(n-i)}$，</li>
<li>由此可知应自底向上计算，保存小的结果。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//products[i]代表f[i]</span></span><br><span class="line">	<span class="keyword">int</span> *products = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>] ;</span><br><span class="line">	products[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// dumps elems</span></span><br><span class="line">	products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//遍历长度i</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=length;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//切割大小为j,只计算前一半即可;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i/<span class="number">2</span>; ++j)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="comment">//根据上述公式计算：取最大那个</span></span><br><span class="line">			<span class="keyword">int</span> product = products[j] * products[i-j];</span><br><span class="line">			<span class="keyword">if</span>(max &lt; product) max = product;	</span><br><span class="line">		&#125;</span><br><span class="line">		products[i] = max;	</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	max = products[length];</span><br><span class="line">	<span class="keyword">delete</span>[] products;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; maxProductAfterCutting(<span class="number">9</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">27</span></span><br><span class="line">​```c++</span><br><span class="line">* greedy：</span><br><span class="line"></span><br><span class="line">​```c++</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCuttingGreedy</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(length == <span class="number">3</span>)</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//尽可能去剪长为3的绳子</span></span><br><span class="line">	<span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// 当绳子为4例外,剪成2*2</span></span><br><span class="line">	<span class="keyword">if</span> (length - timesOf3*<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">			timesOf3-=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) /<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3) * (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>1、机器数<br>一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p>
<p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p>
<p>那么，这里的 00000011 和 10000011 就是机器数。</p>
<p>2、真值<br>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
<p>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0001</span>的真值 = +<span class="number">000</span> <span class="number">0001</span> = +<span class="number">1</span>，</span><br><span class="line"><span class="number">1000</span> <span class="number">0001</span>的真值 = –<span class="number">000</span> <span class="number">0001</span> = –<span class="number">1</span>。</span><br></pre></td></tr></table></figure><br>二. 原码, 反码, 补码的基础概念和计算方法.<br>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p>
<ol>
<li>原码<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>]原 = <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"></span><br><span class="line">[<span class="number">-1</span>]原 = <span class="number">1000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1111</span> <span class="number">1111</span> , <span class="number">0111</span> <span class="number">1111</span>]</span><br><span class="line">即</span><br><span class="line">[<span class="number">-127</span> , <span class="number">127</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<ol>
<li>反码<br>反码的表示方法是:</li>
</ol>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [<span class="number">00000001</span>]原 = [<span class="number">00000001</span>]反</span><br><span class="line"></span><br><span class="line">[<span class="number">-1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反</span><br></pre></td></tr></table></figure><br>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<ol>
<li>补码<br>补码的表示方法是:</li>
</ol>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [<span class="number">00000001</span>]原 = [<span class="number">00000001</span>]反 = [<span class="number">00000001</span>]补</span><br><span class="line"></span><br><span class="line">[<span class="number">-1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<p>转：<br>作者：<a href="http://www.cnblogs.com/zhangziqiu/" target="_blank" rel="noopener">张子秋</a><br>出处：<a href="http://www.cnblogs.com/zhangziqiu/" target="_blank" rel="noopener">http://www.cnblogs.com/zhangziqiu/</a></p>
<hr>
<h4 id="（c语言中移位运算只能用于整数，整数A左移1位得到的结果为A-2，右移1位为A-2取整-。"><a href="#（c语言中移位运算只能用于整数，整数A左移1位得到的结果为A-2，右移1位为A-2取整-。" class="headerlink" title="（c语言中移位运算只能用于整数，整数A左移1位得到的结果为A*2，右移1位为A/2取整)。"></a>（c语言中移位运算只能用于整数，整数A左移1位得到的结果为A*2，右移1位为A/2取整)。</h4><ul>
<li>左移运算符$m\operatorname{&lt;&lt;}n$表示把$m$左移$n$位，最左边的$n$位被丢弃，同时在最右边补上$n$个0：<script type="math/tex; mode=display">
00001010 << 2 = 00101000</script></li>
<li>右移运算符$m&gt;&gt;n$表示把$m$右移$n$位，最右边的$n$位被丢弃：<pre><code>1. 如果数字是一个无符号数值，则用0填补最左边的$n$位；
2. 如果数字是一个有符号数值，则用数值的符号位填补最左边$n$位。也就是说，正数在左边补0，负数在左边补1:
</code></pre></li>
</ul>
<script type="math/tex; mode=display">
00001010 >> 2 = 00000010\\
10001010 >> 3 = 11110001</script><p>其中第二个的符号位是1。</p>
<p>常用<code>m&gt;&gt;1</code>表示<code>m/2</code>, <code>m&amp;1</code>表示<code>m%2</code>。</p>
<ol>
<li>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)</span><br><span class="line">         &#123;</span><br><span class="line">             ++count;</span><br><span class="line">             n = (n<span class="number">-1</span>) &amp; n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>Reference:<ul>
<li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a></li>
</ul>
</li>
</ul>
<p>56、出现一次的数字</p>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<ul>
<li>解析：    //方法：考虑异或运算，两个想等的数异或运算之后等于0，整个数组做异或运算，其中两个<br>  //数字不一样的异或运算之后某一位肯定为1，按照这一位为1对数组做划分，使得两个子数组<br>  //部分只各有一个出现一次的数字<br>  //两个相同数字异或=0，一个数和0异或还是它本身。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty() || data.size()&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> resultExclusiveOR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.size();++i)</span><br><span class="line">            resultExclusiveOR ^= data[i];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> indexOf1 = FindFirstBitIs1(resultExclusiveOR);</span><br><span class="line">        *num1 = *num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;data.size();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isBit1(data[j], indexOf1)) <span class="comment">//按第indexOf1位是否为1划分数组</span></span><br><span class="line">                *num1 ^= data[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2 ^= data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">FindFirstBitIs1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexBit=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按位与，都为1的时候该位才为1，最低位是1，若num的该位也是1，结果为0，便是找到了；否则为1，继续循环</span></span><br><span class="line">        <span class="keyword">while</span>(((num&amp;<span class="number">1</span>)==<span class="number">0</span>) &amp;&amp; (indexBit &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            num= num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ++indexBit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexBit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右移indexBit位，返回该位是否为1；</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> indexBit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num = num &gt;&gt; indexBit;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<ul>
<li>如图：$a_n=2(a_n-1)$；<br><img src="https://upload-images.jianshu.io/upload_images/5433630-85fe57149b32b741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number ==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*jumpFloorII(number<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
2.</li>
</ul>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387?f=discussion</a><br>来源：牛客网</p>
<p>其实是隔板问题，假设n个台阶，有n-1个空隙，可以用0~n-1个隔板分割，c(n-1,0)+c(n-1,1)+…+c(n-1,n-1)=2^(n-1)，其中c表示组合。</p>
<p>有人用移位1&lt;&lt;—number，这是最快的。直接连续乘以2不会慢多少，编译器会自动优化。不过移位还是最有启发的！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        int a&#x3D;1;</span><br><span class="line">        return a&lt;&lt;(number-1); &#x2F;&#x2F;等价于2的（number-1）次方；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>前言</p>
<p>回溯法适合多个步骤组成的问题，每个步骤有多个选项，形成一颗树状。</p>
<p>在叶节点的状态不满足条件，回溯到上一个节点尝试其他的选项。如果再不满足，继续回溯。</p>
<h4 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="1. 矩阵中的路径"></a>1. 矩阵中的路径</h4><blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows&lt;<span class="number">1</span> || cols&lt;<span class="number">1</span> || str == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//记录是否遍历过，回溯的时候需要重置</span></span><br><span class="line">        <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rows; ++row)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;cols;++col)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hasPathCore(matrix,rows,cols,row,col,str,pathLength,visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//矩阵里matrix[row][col]开始的是否有路径pathLength,当str[pathLength]==‘\0’时表示已找到该路径</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*matrix,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>*str,<span class="keyword">int</span>&amp;pathLength,<span class="keyword">bool</span>*visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//终止递归的条件之一</span></span><br><span class="line">        <span class="keyword">if</span>(str[pathLength]==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> hasPath=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//路径第pathLength个元素等于char矩阵该位置的元素</span></span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span> &amp;&amp; row&lt;rows &amp;&amp; col&gt;=<span class="number">0</span> &amp;&amp; col&lt;cols &amp;&amp; matrix[row*cols+col] == str[pathLength] &amp;&amp; !visited[row*cols + col])</span><br><span class="line">        &#123;</span><br><span class="line">            ++pathLength;<span class="comment">//下一个字符</span></span><br><span class="line">            visited[row*cols+col] = <span class="literal">true</span>; <span class="comment">//已经访问</span></span><br><span class="line">            <span class="comment">//四个方向的递归</span></span><br><span class="line">            hasPath = hasPathCore(matrix,rows,cols,row<span class="number">-1</span>,col,str,pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix,rows,cols,row+<span class="number">1</span>,col,str,pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix,rows,cols,row,col<span class="number">-1</span>,str,pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix,rows,cols,row,col+<span class="number">1</span>,str,pathLength, visited);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!hasPath)<span class="comment">//回溯</span></span><br><span class="line">            &#123;</span><br><span class="line">                --pathLength;</span><br><span class="line">                visited[row*cols+col] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-机器人的运动范围"><a href="#2-机器人的运动范围" class="headerlink" title="2. 机器人的运动范围"></a>2. 机器人的运动范围</h4><blockquote>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//threshold:不能进入大于threshold的格子</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(threshold&lt;<span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows*cols);</span><br><span class="line">        <span class="comment">//返回可以走到的格子数目,从起点0,0开始走</span></span><br><span class="line">        <span class="keyword">int</span> count = movingCountCore(threshold,rows,cols,<span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//还是传入具体的坐标值与访问表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col,<span class="keyword">bool</span>*visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//一开始无格子</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(threshold, rows,cols,row,col,visited))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//已经走过</span></span><br><span class="line">            visited[row*cols +col] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            count = <span class="number">1</span>+movingCountCore(threshold,rows,cols,row<span class="number">-1</span>,col,visited)</span><br><span class="line">                + movingCountCore(threshold, rows,cols,row+<span class="number">1</span>,col,visited)</span><br><span class="line">                + movingCountCore(threshold, rows,cols,row,col<span class="number">-1</span>,visited)</span><br><span class="line">                + movingCountCore(threshold, rows,cols,row,col+<span class="number">1</span>,visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col,<span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//row从0到rows-1范围</span></span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span> &amp;&amp; row&lt;rows &amp;&amp; col&gt;=<span class="number">0</span> &amp;&amp; col&lt;cols &amp;&amp; getDigitSum(row)+getDigitSum(col)&lt;=threshold</span><br><span class="line">          &amp;&amp; !visited[row*cols+col])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(number&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=number % <span class="number">10</span>;</span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="字符串、链表"><a href="#字符串、链表" class="headerlink" title="字符串、链表"></a>字符串、链表</h3><p>前言<br>c/c++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line">		<span class="keyword">char</span> str2[] = <span class="string">"helle world"</span>;</span><br><span class="line">		<span class="keyword">char</span>* str3 = <span class="string">"hello world"</span>;</span><br><span class="line">		<span class="keyword">char</span>* str4 = <span class="string">"hello world"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(str1 == str2)</span><br><span class="line">		 	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 and str2 are same.\n"</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt;	<span class="string">"str1 and str2 are not same.\n"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(str3==str4)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"str3 and str4 are same.\n"</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"str3 and str4 are not same.\n"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ./main</span><br><span class="line">str1 <span class="keyword">and</span> str2 are <span class="keyword">not</span> same.</span><br><span class="line">str3 <span class="keyword">and</span> str4 are same.</span><br></pre></td></tr></table></figure>
<p>第一个不同是因为两个不同的数组地址；第二个相同是因为常量字符串在内存中只有一个拷贝，他们都指向同一地址。</p>
<h4 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h4><blockquote>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<ul>
<li>解析：先计算增大串长后的长<code>newStrLength</code>，用指针2指向该位置，同时指针1指向未增长时串中字符的结尾<code>&#39;\0&#39;</code>，从后遍历复制指针1、2上的字符。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">nullptr</span> || length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> strLength=<span class="number">0</span>, space=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先求替换后的字符串大小</span></span><br><span class="line">        <span class="keyword">while</span>(str[strLength]!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(str[strLength]==<span class="string">' '</span>)</span><br><span class="line">                ++space;</span><br><span class="line">            ++strLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//strLength指向终止符处</span></span><br><span class="line">        <span class="comment">//增大后的串长</span></span><br><span class="line">        <span class="keyword">int</span> newStrLength = strLength+<span class="number">2</span>*space;</span><br><span class="line">        <span class="keyword">if</span> (newStrLength &gt; length)<span class="comment">//length为该串总容量</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(strLength&gt;=<span class="number">0</span> &amp;&amp; newStrLength&gt;strLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[strLength]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str[newStrLength--] = <span class="string">'0'</span>;</span><br><span class="line">                str[newStrLength--] = <span class="string">'2'</span>;</span><br><span class="line">                str[newStrLength--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                str[newStrLength--]=str[strLength]; </span><br><span class="line">            &#125;</span><br><span class="line">            --strLength;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="19、正则表达式"><a href="#19、正则表达式" class="headerlink" title="19、正则表达式"></a>19、正则表达式</h4><blockquote>
<p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
</blockquote>
<ul>
<li>解：当遇到<code>*</code>的时候可以当做前面的字符（一个字符）出现了0次，也就是忽略<code>*</code>直接前移2步，也可以当做出现n次，在原处待着不动，让str前移n步去比较；退出条件是看str是否为空且模式也为空就是匹配上，否则没有匹配上，递归的调用看各种情况下返回的是否有一个满足条件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">nullptr</span> || pattern==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//若同时结束对比为匹配</span></span><br><span class="line">    <span class="keyword">if</span>(*str==<span class="string">'\0'</span> &amp;&amp; *pattern==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*str!=<span class="string">'\0'</span> &amp;&amp; *pattern==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)==<span class="string">'*'</span>)<span class="comment">//若下一个字符为需要匹配的字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前以及匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*pattern==*str || (*pattern ==<span class="string">'.'</span> &amp;&amp; *str!=<span class="string">'\0'</span>))</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//move on the next state || stay on current state || 向前移动2步，忽略一个‘*’匹配；</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str+<span class="number">1</span>, pattern+<span class="number">2</span>) || matchCore(str+<span class="number">1</span>,pattern) || matchCore(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//向前移动2步，忽略一个‘*’匹配；</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前字符以及匹配，去往下面的字符；</span></span><br><span class="line">    <span class="keyword">if</span> (*str==*pattern || (*pattern==<span class="string">'.'</span> &amp;&amp; *str!=<span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> matchCore(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="38、字符串的排列"><a href="#38、字符串的排列" class="headerlink" title="38、字符串的排列"></a>38、字符串的排列</h4><blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote>
<ul>
<li>解析：第一个字符固定为i，剩下其他字符的全排列在后面；i的取值是整个字符串的取值，因此，每次交换头字符，还有后面字符串中的下一个字符；递归结束条件是该字符串已经找到；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">        Permutation(str,result,<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 此时得到的result中排列并不是字典顺序，可以单独再排下序</span></span><br><span class="line">        sort(result.begin(),result.end());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result,<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == str.size()<span class="number">-1</span>) <span class="comment">// 递归结束条件：索引已经指向str最后一个元素时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(result.begin(),result.end(),str) == result.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果result中不存在str，才添加；避免aa和aa重复添加的情况</span></span><br><span class="line">                result.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一次循环i与begin相等，相当于第一个位置自身交换，关键在于之后的循环，</span></span><br><span class="line">            <span class="comment">// 之后i != begin，则会交换两个不同位置上的字符，直到begin==str.size()-1，进行输出；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;str.size();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(str[i],str[begin]);</span><br><span class="line">                Permutation(str,result,begin+<span class="number">1</span>);</span><br><span class="line">                swap(str[i],str[begin]); <span class="comment">// 复位，用以恢复之前字符串顺序，达到第一位依次跟其他位交换的目的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> &amp;fir,<span class="keyword">char</span> &amp;sec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = fir;</span><br><span class="line">        fir = sec;</span><br><span class="line">        sec = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>内存分配不是在创建链表时一次完成的，而是每次添加一个节点是分配内存；因此没有闲置的内存，链表的空间效率比数组高。</li>
</ul>
<ul>
<li><p>指针的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example program</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line">    <span class="keyword">int</span> **ppi = &amp;pi;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"*pi :"</span> &lt;&lt; *pi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;pi :"</span> &lt;&lt; &amp;pi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"*ppi :"</span> &lt;&lt; *ppi&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pi :<span class="number">1</span></span><br><span class="line">&amp;pi :<span class="number">0x70aa208f64e8</span></span><br><span class="line">*ppi :<span class="number">0x70aa208f64e4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链表的尾部添加节点和删除值为某数的节点如下：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example program</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	ListNode *pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//pHead是二级指针，指向指针的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToTail</span><span class="params">(ListNode** pHead,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ListNode* pNew = <span class="keyword">new</span> ListNode();</span><br><span class="line">	pNew-&gt;value = value;</span><br><span class="line">	pNew-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//是否为根节点</span></span><br><span class="line">	<span class="keyword">if</span>((*pHead)==<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//取出头指针指向当前新节点</span></span><br><span class="line">		*pHead = pNew;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode *pNode=*pHead;</span><br><span class="line">		<span class="comment">//通过指针链接新节点在尾部</span></span><br><span class="line">		<span class="keyword">while</span>(pNode-&gt;pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">					pNode = pNode-&gt;pNext;</span><br><span class="line">		pNode-&gt;pNext =pNew;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某值元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveNode</span><span class="params">(ListNode** pHead, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pHead==<span class="literal">nullptr</span> || *pHead==<span class="literal">nullptr</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//指向要删除的元素标记指针</span></span><br><span class="line">	ListNode* pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否删除位置在头结点</span></span><br><span class="line">	<span class="keyword">if</span>((*pHead)-&gt;value == value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//标记</span></span><br><span class="line">		pToBeDeleted = *pHead;</span><br><span class="line">		<span class="comment">//新的头结点位置在下一个位置</span></span><br><span class="line">		*pHead=(*pHead)-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//根节点的地址</span></span><br><span class="line">		ListNode* pNode=*pHead;</span><br><span class="line">		<span class="keyword">while</span>(pNode-&gt;pNext != <span class="literal">nullptr</span></span><br><span class="line">		&amp;&amp; pNode-&gt;pNext-&gt;value!=value)</span><br><span class="line">			pNode=pNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//找到该元素的位置,为pNode的下一个位置</span></span><br><span class="line">		<span class="keyword">if</span>(pNode-&gt;pNext!=<span class="literal">nullptr</span> &amp;&amp; pNode-&gt;pNext-&gt;value==value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//该元素位置下一个位置赋给pToBeDeleted</span></span><br><span class="line">			pToBeDeleted = pNode-&gt;pNext;</span><br><span class="line">			<span class="comment">//删除元素前一个位置的pNext链接到删除元素的下一个位置;之后就可以安全的删除了</span></span><br><span class="line">			pNode-&gt;pNext = pNode-&gt;pNext-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除该标记指针</span></span><br><span class="line">	<span class="keyword">if</span>(pToBeDeleted!=<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">		pToBeDeleted = <span class="literal">nullptr</span>; <span class="comment">//避免出错，赋为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		ListNode *test;</span><br><span class="line">		ListNode** PP = &amp;test;</span><br><span class="line">		AddToTail(PP, <span class="number">20</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		AddToTail(PP, <span class="number">30</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test-&gt;pNext-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		RemoveNode(PP,<span class="number">20</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<h4 id="6-输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"><a href="#6-输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。" class="headerlink" title="6. 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"></a>6. 输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归求解，或者用栈来求解。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(st.top()-&gt;val);</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-删除链表中重复的元素"><a href="#18-删除链表中重复的元素" class="headerlink" title="18. 删除链表中重复的元素"></a>18. 删除链表中重复的元素</h4><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//需要三个指针前中后</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *pPreNode = <span class="literal">nullptr</span>; <span class="comment">//前一个节点</span></span><br><span class="line">        ListNode *pNode = pHead; <span class="comment">//当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode * pNextNode = pNode-&gt;next;<span class="comment">//重置为当前节点的下一节点</span></span><br><span class="line">            <span class="keyword">bool</span> needDelete=<span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//下一节点和当前节点是否是重复的</span></span><br><span class="line">            <span class="keyword">if</span>(pNextNode!=<span class="literal">nullptr</span> &amp;&amp; pNode-&gt;val==pNextNode-&gt;val)</span><br><span class="line">                needDelete = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!needDelete)<span class="comment">//没有重复，往下走</span></span><br><span class="line">            &#123;</span><br><span class="line">                pPreNode = pNode;</span><br><span class="line">                pNode = pNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//重复节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//取出值，删除连续等于该值的节点</span></span><br><span class="line">                <span class="keyword">int</span> value = pNode-&gt;val;</span><br><span class="line">                ListNode* pToBeDel = pNode;</span><br><span class="line">                <span class="comment">//连续删除</span></span><br><span class="line">                <span class="keyword">while</span>(pToBeDel != <span class="literal">nullptr</span> &amp;&amp; pToBeDel-&gt;val == value)</span><br><span class="line">                &#123;</span><br><span class="line">                    pNextNode = pToBeDel-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> pToBeDel;</span><br><span class="line">                    pToBeDel = <span class="literal">nullptr</span>;</span><br><span class="line">                    pToBeDel = pNextNode;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//确定是否是头结点</span></span><br><span class="line">            <span class="keyword">if</span>(pPreNode == <span class="literal">nullptr</span>)</span><br><span class="line">                pHead = pNextNode;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//删除之后重链接删除后的节点</span></span><br><span class="line">                pPreNode-&gt;next = pNextNode;</span><br><span class="line">            pNode=pNextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="17-输入一个链表，输出该链表中倒数第k个结点。"><a href="#17-输入一个链表，输出该链表中倒数第k个结点。" class="headerlink" title="17. 输入一个链表，输出该链表中倒数第k个结点。"></a>17. 输入一个链表，输出该链表中倒数第k个结点。</h4><ul>
<li>双指针开始走，第一个走到k-1步时，第二个开始从根节点走。判断链长是否有k，没有解返回。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pListHead || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* preListNode=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curListNode=pListHead;</span><br><span class="line">        <span class="comment">//第一个指针走了k-1步，加上本身是一个位移，总共k位移，第二个指针开始从头结点走1步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">1</span>;i&lt;k;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curListNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curListNode=curListNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//链表长度不足</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始走</span></span><br><span class="line">        preListNode = pListHead;</span><br><span class="line">        <span class="comment">//下一个节点指针非空</span></span><br><span class="line">        <span class="keyword">while</span>(curListNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curListNode=curListNode-&gt;next;</span><br><span class="line">            preListNode=preListNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preListNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23.链表中环的入口节点"></a>23.链表中环的入口节点</h4><blockquote>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
</blockquote>
<p>解：1. 确定链表是否有环；（设置一个走得快的指针是否能追上走得慢的指针；）</p>
<pre><code>    2. 环的大小是多少；
    3. 快指针先走环的大小步数，慢指针再走，必然在环的入口处相遇。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//meetingnode返回该链表是否有环，有的情况下，返回快慢指针相遇的节点</span></span><br><span class="line">        ListNode* ListMeetNode=MeetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span>(ListMeetNode==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> countLoop=<span class="number">1</span>;</span><br><span class="line">        ListNode* pNode = ListMeetNode;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;next!=ListMeetNode)</span><br><span class="line">        &#123;</span><br><span class="line">            countLoop++;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode=pHead;</span><br><span class="line">        ListNode *slowNode=pHead;</span><br><span class="line">        <span class="comment">//先走k-1步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;countLoop;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=slowNode)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">            slowNode=slowNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">MeetingNode</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="comment">//空链表的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pslow=head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pslow==<span class="literal">nullptr</span>)<span class="comment">//无环的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pfast=pslow-&gt;next;<span class="comment">//快一步</span></span><br><span class="line">        <span class="keyword">while</span>(pfast!= <span class="literal">nullptr</span> &amp;&amp; pslow!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pfast==pslow)<span class="comment">//有环</span></span><br><span class="line">                <span class="keyword">return</span> pfast;</span><br><span class="line">            pslow = pslow-&gt;next;</span><br><span class="line">            pfast = pfast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pfast!=<span class="literal">nullptr</span>)<span class="comment">//多走一步</span></span><br><span class="line">                pfast=pfast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h4><blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<ul>
<li>解析：重复各个节点，然后关联新的重复节点的random，再然后重链接取出偶数链接的链表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//复制原始链表的任一节点N并创建新节点N'，再把N'链接到N的后边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* pNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pCloned=<span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            pCloned-&gt;label=pNode-&gt;label;</span><br><span class="line">            pCloned-&gt;next=pNode-&gt;next;</span><br><span class="line">            pCloned-&gt;random=<span class="literal">NULL</span>;</span><br><span class="line">              </span><br><span class="line">            pNode-&gt;next=pCloned;</span><br><span class="line">              </span><br><span class="line">            pNode=pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果原始链表上的节点N的random指向S，则对应的复制节点N'的random指向S的下一个节点S'</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConnectRandomNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* pNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pCloned=pNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;random!=<span class="literal">NULL</span>)</span><br><span class="line">                pCloned-&gt;random=pNode-&gt;random-&gt;next;</span><br><span class="line">            pNode=pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把得到的链表拆成两个链表，奇数位置上的结点组成原始链表，偶数位置上的结点组成复制出来的链表</span></span><br><span class="line">    <span class="function">RandomListNode* <span class="title">ReConnectNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* pNode=pHead;</span><br><span class="line">        RandomListNode* pClonedHead=<span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* pClonedNode=<span class="literal">NULL</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pClonedHead=pClonedNode=pNode-&gt;next;</span><br><span class="line">            pNode-&gt;next=pClonedNode-&gt;next;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pClonedNode-&gt;next=pNode-&gt;next;</span><br><span class="line">            pClonedNode=pClonedNode-&gt;next;</span><br><span class="line">            pNode-&gt;next=pClonedNode-&gt;next;</span><br><span class="line">            pNode=pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> pClonedHead;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三步合一</span></span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CloneNodes(pHead);</span><br><span class="line">        ConnectRandomNodes(pHead);</span><br><span class="line">        <span class="keyword">return</span> ReConnectNodes(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="52、两个链表的第一个公共节点"><a href="#52、两个链表的第一个公共节点" class="headerlink" title="52、两个链表的第一个公共节点"></a>52、两个链表的第一个公共节点</h4><blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<ul>
<li>解：    方法1：对链表1中每一个节点，都遍历一遍链表2，复杂度为O(mn);m\n分别为两个链表的长度；<br>  方法2：若中间某一个节点相同，之后剩下的节点都是一样的地址存在，因此结尾处都一样，<br>  设置栈结构，从尾部排除，遇到不相等的元素时，之前的那个元素便是第一个相同的元素点，空间换时间<br>  的O(m+N)空间换取时间为O(m+n);<br>  方法3：先遍历两个链表得到最长链表的长度s1与短链表的长度s2，在最长链表上先移动s1-s2,再同时移动<br>  链表1,2，且不断比较直到相等；</li>
</ul>
<p>方法3的原因是：链表$A$长度是$LA$，链表$B$长度是$LB$，他们的公共部分长度是$LC$，那么不妨设$LA$长度更长，那么有：$ LA&gt;LB \ge LC$,那么$A$与$B$的公共部分至少在$A$后面的长度还有$B$这么长的时候才有可能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1 || !pHead2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *pDupHead1 = pHead1;</span><br><span class="line">        ListNode *pDupHead2 = pHead2;</span><br><span class="line">        <span class="keyword">int</span>  count1=<span class="number">0</span>, count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pHead1)</span><br><span class="line">        &#123;</span><br><span class="line">            count1++;</span><br><span class="line">            pHead1=pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pHead2)</span><br><span class="line">        &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            pHead2=pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1&gt;count2) <span class="comment">//链表1最长</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lCount = count1 - count2;</span><br><span class="line">            <span class="keyword">while</span>(lCount--)</span><br><span class="line">                pDupHead1=pDupHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lCount = count2 - count1;</span><br><span class="line">            <span class="keyword">while</span>(lCount--)</span><br><span class="line">               pDupHead2 = pDupHead2-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pDupHead1 &amp;&amp; pDupHead2 &amp;&amp; (pDupHead1!=pDupHead2))</span><br><span class="line">        &#123;</span><br><span class="line">            pDupHead1 = pDupHead1-&gt;next;</span><br><span class="line">            pDupHead2 = pDupHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * pFirstCommonNode = pDupHead1;</span><br><span class="line">        <span class="keyword">return</span> pFirstCommonNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="50、第一个只出现一次的字符"><a href="#50、第一个只出现一次的字符" class="headerlink" title="50、第一个只出现一次的字符"></a>50、第一个只出现一次的字符</h4><blockquote>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
</blockquote>
<ul>
<li>:方法1：暴力求解,对当前每一个字符，搜索后面的真个字符串，复杂度是O(n^2);<br>方法2：哈希表：自建一个简单哈希表；<br>可以把哈希表设为256，因为char是8bit的类型，总共只有256个字符，<br>可以设置哈希表为负，第一次插入后为正，再次插入同样的字符，设为负，下次只有找出数组非负的位置便是对应的第一次出现的字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">26</span>*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'a'</span>&lt;=i &amp;&amp; i&lt;=<span class="string">'z'</span>)</span><br><span class="line">                arr[<span class="keyword">int</span>(i-<span class="string">'a'</span>)]+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arr[<span class="keyword">int</span>(i-<span class="string">'A'</span>)+<span class="number">26</span>]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;str.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> numj;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'a'</span>&lt;=str[j] &amp;&amp; str[j]&lt;= <span class="string">'z'</span>)</span><br><span class="line">                numj=<span class="keyword">int</span>( str[j]-<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                numj=<span class="keyword">int</span>( str[j]-<span class="string">'A'</span>+<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[numj] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="58、反转单词顺序字符串"><a href="#58、反转单词顺序字符串" class="headerlink" title="58、反转单词顺序字符串"></a>58、反转单词顺序字符串</h4><blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<ul>
<li>先反转整个串，再反转每一个单词；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        reverse(str.begin(),str.end());</span><br><span class="line">        <span class="keyword">int</span> size = str.size();</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//起点为空，重置游标</span></span><br><span class="line">            <span class="keyword">while</span>(begin&lt;size &amp;&amp; str[begin]==<span class="string">' '</span>) begin++;</span><br><span class="line">            end=begin;</span><br><span class="line">            <span class="comment">//终点不为空，一直往前走到头</span></span><br><span class="line">            <span class="keyword">while</span>(end&lt;size &amp;&amp; str[end]!=<span class="string">' '</span>) end++;</span><br><span class="line">            reverse(str.begin()+begin, str.begin()+end);</span><br><span class="line">            <span class="comment">//反转之后，起点的顺序是重点的顺序</span></span><br><span class="line">            begin = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2。左旋转字符串"><a href="#2。左旋转字符串" class="headerlink" title="2。左旋转字符串"></a>2。左旋转字符串</h4><blockquote>
<p>字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<ul>
<li>先翻转这个串的前后两部分，然后再全部一次性翻转<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.empty() || n&lt;=<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        reverse(str.begin(),str.begin()+n);</span><br><span class="line">        reverse(str.begin()+n,str.end());</span><br><span class="line">        reverse(str.begin(),str.end());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="67、将一个字符串转换成一个整数"><a href="#67、将一个字符串转换成一个整数" class="headerlink" title="67、将一个字符串转换成一个整数"></a>67、将一个字符串转换成一个整数</h4><blockquote>
<p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> minus;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">            minus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            minus = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]!=<span class="string">'+'</span> &amp;&amp; str[<span class="number">0</span>]!=<span class="string">'-'</span>) i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;str.size();++i)</span><br><span class="line">        &#123;           </span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span> &amp;&amp; str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + minus * (str[i]-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num; <span class="comment">//类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="50、字符流中第一个出现的字符"><a href="#50、字符流中第一个出现的字符" class="headerlink" title="50、字符流中第一个出现的字符"></a>50、字符流中第一个出现的字符</h4><p>方法1：用常规方法来解：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="comment">//全部初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> hash[<span class="number">256</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        str+=ch;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = str.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[str[i]]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>方法2：用stl来解：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;    <span class="comment">//用map来记录字符出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        str += ch;</span><br><span class="line">        m[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[it] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。"><a href="#请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。" class="headerlink" title="请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。"></a>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</h4><p>例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记符号、小数点、e是否出现过</span></span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">false</span>, decimal = <span class="literal">false</span>, hasE = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="built_in">strlen</span>(str)<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// e后面一定要接数字</span></span><br><span class="line">                <span class="keyword">if</span> (hasE) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不能同时存在两个e</span></span><br><span class="line">                hasE = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="comment">// 第二次出现+-符号，则必须紧接在e之后</span></span><br><span class="line">                <span class="keyword">if</span> (sign &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">'e'</span> &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">'E'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后</span></span><br><span class="line">                <span class="keyword">if</span> (!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">'e'</span> &amp;&amp; str[i<span class="number">-1</span>] != <span class="string">'E'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">              <span class="comment">// e后面不能接小数点，小数点不能出现两次</span></span><br><span class="line">                <span class="keyword">if</span> (hasE || decimal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                decimal = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>) <span class="comment">// 不合法字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Cooking/" rel="tag"># Cooking</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/04/Primer/C++---CHAPTER-4--EXPRESSION/" rel="next" title="C++---CHAPTER-4---EXPRESSION">
                  <i class="fa fa-chevron-left"></i> C++---CHAPTER-4---EXPRESSION
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/04/Primer/C++---CHAPTER-7--CLASS/" rel="prev" title="C++---CHAPTER-7---CLASS">
                  C++---CHAPTER-7---CLASS <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar/jojo3.jpg"
      alt="Zheng Chu">
  <p class="site-author-name" itemprop="name">Zheng Chu</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
<<<<<<< HEAD
          <span class="site-state-item-count">79</span>
=======
          <span class="site-state-item-count">91</span>
>>>>>>> 7c1172c9875087286cd44bd62769ab39300c7202
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
<<<<<<< HEAD
        <span class="site-state-item-count">19</span>
=======
          
        
        <span class="site-state-item-count">20</span>
>>>>>>> 7c1172c9875087286cd44bd62769ab39300c7202
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
<<<<<<< HEAD
        <span class="site-state-item-count">24</span>
=======
          
        
        <span class="site-state-item-count">25</span>
>>>>>>> 7c1172c9875087286cd44bd62769ab39300c7202
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/zhengchu1994" title="GitHub &rarr; https://github.com/zhengchu1994" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.jianshu.com/u/d4875c485cff" title="简书 &rarr; https://www.jianshu.com/u/d4875c485cff" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://blog.csdn.net/NockinOnHeavensDoor" title="CSDN &rarr; https://blog.csdn.net/NockinOnHeavensDoor" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>CSDN</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:zhengchu@tju.edu.cn" title="E-Mail &rarr; mailto:zhengchu@tju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#队列和栈"><span class="nav-number">1.</span> <span class="nav-text">队列和栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组和数值"><span class="nav-number">2.</span> <span class="nav-text">数组和数值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number"></span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#94-二叉树的非递归前序遍历"><span class="nav-number">1.</span> <span class="nav-text">94. 二叉树的非递归前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#94-二叉树的非递归中序遍历"><span class="nav-number">2.</span> <span class="nav-text">94. 二叉树的非递归中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#145-二叉树的非递归后序遍历"><span class="nav-number">3.</span> <span class="nav-text">145. 二叉树的非递归后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#98-验证二叉搜索树"><span class="nav-number">4.</span> <span class="nav-text">98. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-重建二叉树：根据前序和中序遍历的结果重建二叉树。假设输入的遍历结果都不含有重复的数字。"><span class="nav-number">5.</span> <span class="nav-text">1. 重建二叉树：根据前序和中序遍历的结果重建二叉树。假设输入的遍历结果都不含有重复的数字。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-二叉树的下一个节点：给定一颗二叉树和其中的一个节点，如何找到中序遍历序列的下一个节点，每个节点左右子节点指针，还有指向父节点的指针。"><span class="nav-number">6.</span> <span class="nav-text">2. 二叉树的下一个节点：给定一颗二叉树和其中的一个节点，如何找到中序遍历序列的下一个节点，每个节点左右子节点指针，还有指向父节点的指针。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-树的子结构"><span class="nav-number">7.</span> <span class="nav-text">26. 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27、二叉树的镜像"><span class="nav-number">8.</span> <span class="nav-text">27、二叉树的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28、对称的二叉树"><span class="nav-number">9.</span> <span class="nav-text">28、对称的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32、从下到上打印二叉树"><span class="nav-number">10.</span> <span class="nav-text">32、从下到上打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-2、分行从上到下打印二叉树"><span class="nav-number">11.</span> <span class="nav-text">32.2、分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33、二叉搜索树的后序遍历序列"><span class="nav-number">12.</span> <span class="nav-text">33、二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34、二叉树中和为某一值的路径"><span class="nav-number">13.</span> <span class="nav-text">34、二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36、二叉搜索树与双向链表"><span class="nav-number">14.</span> <span class="nav-text">36、二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37、序列化二叉树"><span class="nav-number">15.</span> <span class="nav-text">37、序列化二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54、请找出其中的第k小的结点"><span class="nav-number">16.</span> <span class="nav-text">54、请找出其中的第k小的结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55、输入一棵二叉树，求该树的深度。"><span class="nav-number">17.</span> <span class="nav-text">55、输入一棵二叉树，求该树的深度。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-2、输入一棵二叉树，判断该二叉树是否是平衡二叉树。"><span class="nav-number">18.</span> <span class="nav-text">55.2、输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按之字形打印树"><span class="nav-number">19.</span> <span class="nav-text">按之字形打印树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#112-Path-Sum"><span class="nav-number">20.</span> <span class="nav-text">112. Path Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#113-Path-Sum-II"><span class="nav-number">21.</span> <span class="nav-text">113. Path Sum II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number"></span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-斐波那契数列：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。"><span class="nav-number">1.</span> <span class="nav-text">1. 斐波那契数列：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。"><span class="nav-number">2.</span> <span class="nav-text">2. 跳台阶：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找、排序"><span class="nav-number"></span> <span class="nav-text">查找、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转数组的最小数字"><span class="nav-number">1.</span> <span class="nav-text">旋转数组的最小数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#统计一个数字在排序数组中出现的次数。"><span class="nav-number">2.</span> <span class="nav-text">统计一个数字在排序数组中出现的次数。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57、和为s的一对数"><span class="nav-number">3.</span> <span class="nav-text">57、和为s的一对数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-和为连续整数的序列"><span class="nav-number">4.</span> <span class="nav-text">2.和为连续整数的序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划"><span class="nav-number"></span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#剪绳子"><span class="nav-number">1.</span> <span class="nav-text">剪绳子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算"><span class="nav-number"></span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（c语言中移位运算只能用于整数，整数A左移1位得到的结果为A-2，右移1位为A-2取整-。"><span class="nav-number">1.</span> <span class="nav-text">（c语言中移位运算只能用于整数，整数A左移1位得到的结果为A*2，右移1位为A&#x2F;2取整)。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯"><span class="nav-number"></span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-矩阵中的路径"><span class="nav-number">1.</span> <span class="nav-text">1. 矩阵中的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-机器人的运动范围"><span class="nav-number">2.</span> <span class="nav-text">2. 机器人的运动范围</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串、链表"><span class="nav-number"></span> <span class="nav-text">字符串、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-替换空格"><span class="nav-number">1.</span> <span class="nav-text">5. 替换空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、正则表达式"><span class="nav-number">2.</span> <span class="nav-text">19、正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38、字符串的排列"><span class="nav-number">3.</span> <span class="nav-text">38、字符串的排列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number"></span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"><span class="nav-number">2.</span> <span class="nav-text">6. 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-删除链表中重复的元素"><span class="nav-number">3.</span> <span class="nav-text">18. 删除链表中重复的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-输入一个链表，输出该链表中倒数第k个结点。"><span class="nav-number">4.</span> <span class="nav-text">17. 输入一个链表，输出该链表中倒数第k个结点。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-链表中环的入口节点"><span class="nav-number">5.</span> <span class="nav-text">23.链表中环的入口节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35、复杂链表的复制"><span class="nav-number">6.</span> <span class="nav-text">35、复杂链表的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52、两个链表的第一个公共节点"><span class="nav-number">7.</span> <span class="nav-text">52、两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50、第一个只出现一次的字符"><span class="nav-number">8.</span> <span class="nav-text">50、第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58、反转单词顺序字符串"><span class="nav-number">9.</span> <span class="nav-text">58、反转单词顺序字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2。左旋转字符串"><span class="nav-number">10.</span> <span class="nav-text">2。左旋转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67、将一个字符串转换成一个整数"><span class="nav-number">11.</span> <span class="nav-text">67、将一个字符串转换成一个整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50、字符流中第一个出现的字符"><span class="nav-number">12.</span> <span class="nav-text">50、字符流中第一个出现的字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。"><span class="nav-number">13.</span> <span class="nav-text">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Chu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', function() {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
    var gitalk = new Gitalk({
      clientID: '0911ce8ceab7f12409f0',
      clientSecret: '6fa693e25bfc0f98e5cc0907c97cb2fe9f54bb5e',
      repo: 'Gitalk',
      owner: 'zhengchu1994',
      admin: ['zhengchu1994'],
      id: '3428f50117251a20ace7335b59cdce6b',
        language: window.navigator.language || window.navigator.userLanguage,
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
