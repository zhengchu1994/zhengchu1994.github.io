---
 title: 算法Basic--math
mathjax: true
date: 2019-09-20 21:53:32
tags: [Acwing, Algorithm]
categories: 算法与数据结构
visible:
---





## 质数

* 定义：在大于1的整数中，如果只包含1和本身这两个约数，称为质数，或素数。
* （2）一个[质数](https://baike.baidu.com/item/质数)，另一个不为它的倍数，这两个数为互质数。例如，3与10、5与 26。

 约数：

* 又称[因数](https://baike.baidu.com/item/因数/9539111)。[整数](https://baike.baidu.com/item/整数/1293937)a除以整数b(b≠0) 除得的商正好是整数而没有[余数](https://baike.baidu.com/item/余数/6180737)，我们就说a能被b整除，或b能整除a。a称为b的[倍数](https://baike.baidu.com/item/倍数/7827981)，b称为a的约数。



#### 试除法判定质数

* 试除法：`O(n)`.

```c++
bool is_prime(int x)
{
    if (x < 2) return false;
    for(int i = 2; i < x; i ++)
        if(x % i == 0)
            return false;
    return true;
}
```

* 由于约数是成对出现的，因此对于`d`是不是`n`的约数，只需要判断`d <= n/d`。复杂度`O(sqrt(n))`.

```c++
bool is_prime(int x)
{
    if (x < 2) return false;
    for(int i = 2; i <= x/i; i ++)
        if(x % i == 0)
            return false;
    return true;
}
```



#### 分解质因数



质因数 Prime Factors ： 每个[合数](https://baike.baidu.com/item/合数)都可以写成几个质数（也可称为[素数](https://baike.baidu.com/item/素数/115069)）相乘的形式 [2] ，这几个质数就都叫做这个合数的质因数。如果一个质数是某个数的[因数](https://baike.baidu.com/item/因数/9539111)，那么就说这个质数是这个数的质因数；而这个因数一定是一个质数。 



 分解质因数可将正整数表示为一连串的**质因子**相乘，**质因子**如重复可以用指数表示。 

* `n`中最多只包含一个大于`sqrt(n)`的质因子。时间复杂度最坏是`O(sqrt(n))`，最好`O(lgn)`

```c++
#include<iostream>

using namespace std;


void divide(int n)
{
    for(int i = 2; i <= n / i; i ++) //n中最多只包含一个大于sqrt(n)的质因子。
    {
        if(n % i == 0)
        {
            int s = 0; //底数
            while(n % i == 0) n /= i, s++;
            cout << i << " " << s << endl;
        }
    }
    if(n > 1) cout << n << " " << 1 << endl; //`n`中最多只包含一个大于`sqrt(n)`的质因子
    cout << endl;
}
int main()
{
    int n; cin >> n;
    while ( n --)
    {
        int x; cin >> x;
        divide(x);
    }
    
    return 0;
}

```



*  **算术基本定理**，又称为**[正整数](https://zh.wikipedia.org/wiki/正整數)的唯一分解定理**，即：每个大于1的[自然数](https://zh.wikipedia.org/wiki/自然数)，要么本身就是[质数](https://zh.wikipedia.org/wiki/质数)，要么可以写为2个或以上的质数的[积](https://zh.wikipedia.org/wiki/积)，而且这些质因子按大小排列之后，写法仅有一种方式。 

####  筛质数 

质数定理：1~n中有n/ log n 个质数。

埃氏筛法$O(nlglgn)$ ：只去筛掉质数的倍数，

算数基本定理，任何一个整数`n`都能被分解如下：$n = p_1^{k_1}p_2^{k_2}...p_t^{k_t}$

```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;
int prime[N], cnt;
bool st[N];


int get_prime(int x)
{
    for(int i = 2; i <= x; i ++)
    {
        if(!st[i])
        {
            prime[cnt++] = i;
            for(int j = i+i; j <= x; j += i) st[j] = true;
        }
        
    }
    return cnt;
}
int main()
{
    int x;
    cin >> x;
    cout << get_prime(x) << endl;
    return 0;
}
```

线性筛法：

* 思想：`n`只会被最小质因子筛掉。

* 对于一个合数`x`，假设`prime[x]`是x的最小质因子，当`i`枚举到`x/prime[j]`的时候，`x`一定会被筛掉。

* ```pseudocode
  1.i%prime[j] == 0, prime[j]一定为i最小质因子，prime[j]也一定为prime[j]*i最小质因子
  2.i%prime[j] != 0, prime[j]一定小于i的所有质因子，所以prime[j]也为prime[j]*i最小质因子
  ```

```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;
int prime[N], cnt;
bool st[N];


int get_prime(int x)
{
    for(int i = 2; i <= x; i ++)
    {
        if(!st[i]) prime[cnt++] = i;
        for(int j = 0; prime[j] <= x / i; j ++)
        {
            //对于任意一个合数x，假设prime[j]为x最小质因子，当i<x/prime[j]时，一定会被筛掉
            st[prime[j] * i] = true;
            /*
            1.i%prime[j] == 0, prime[j]一定为i最小质因子，prime[j]也一定为prime[j]*i最小质因子
            2.i%prime[j] != 0, prime[j]一定小于i的所有质因子，所以prime[j]也为prime[j]*i最小质因子
            */
            if(i % prime[j] == 0) break;
        }
    }
    return cnt;
}
int main()
{
    int x;
    cin >> x;
    cout << get_prime(x) << endl;
    return 0;
}
```

python：

```python
def get_prime(x):
    st = [False] * (x + 1)
    ans = []
    for i in range(2, x + 1):
        if not st[i]:
            ans.append(i)
        j = 0
        while j < len(ans) and ans[j] <= x // i:
            st[ans[j] * i] = True
            if i // ans[j] == 0:
                break
            j += 1
    return len(ans)

if __name__ == "__main__":
    x = int(input())
    print(get_prime(x))
```



## 约数

存在整数 $k$，使得$a=kd$，则称$d|a$（d 整除 a）。

- d为a的约数，a为d的倍数。
- 任何数都是0的约数

#### 试除法求约数

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> get_divisors(int x)
{
    vector<int> nums;
    for(int i = 1; i <= x / i; i ++)
        if(x % i == 0)
        {
            nums.push_back(i);
            if(i != x / i) nums.push_back(x/i); //防止i*i=x，放入同一个约数两次
        }
    sort(nums.begin(), nums.end());
    return nums;
}
int main()
{
    int n;
    cin >> n;
    while (n --)
    {
        int x;
        cin >> x;
        auto res = get_divisors(x);
        for(auto t :res) cout << t << " ";
        cout << endl;
    }
    return 0;
}
```



#### 约数个数

由算数基本定理：$$n = p_1^{k_1}p_2^{k_2}...p_t^{k_t}$$,

约数个数为$(k_1 + 1)* (k_2 + 1) *..(k_t + 1)$

约数之和$(p_1^0 + p_1^1 +..p_1^{k_1}) * (p_2^0 + p_2^1 +..p_2^{k_2})...* (p_t^0 + p_t^1 +..p_t^{k_t})$

```c++
#include <iostream>
#include <unordered_map>

using namespace std;
const int mod = 1e9 + 7;
typedef long long LL;
int main()
{
    int n;
    cin >> n;
    unordered_map<int, int> primes;
    
    while(n --)
    {
        int x;
        cin >> x;
        for(int i = 2; i <= x / i; i ++)
        {    
            while(x % i == 0)
            {
                x /= i;
                primes[i]++;
            }
        }
        if (x > 1) primes[x]++;
    }
    LL res = 1;
    for(auto  prime : primes)
        res = res * (prime.second + 1) % mod;
    cout << res << endl;
    return 0;
}
```



#### 约数之和

```c++
#include <iostream>
#include <unordered_map>

using namespace std;
typedef long long ll;
const int mod = 1e9 +7;

int main()
{
    int n;
    cin >> n;
    unordered_map<int, int> primes;
    while(n --)
    {
        int x; cin >> x;
        for(int i = 2; i <= x / i; i ++)
            while(x % i == 0)
            {
                x /= i;
                primes[i]++;
            }
        if (x > 1) primes[x] ++;
    }
    
    ll res = 1;
    for(auto prime : primes)
    {
        ll cnt = 1;
        for(int i = 0; i < prime.second; i ++)
            cnt = (cnt * prime.first + 1) % mod;
        res = res * cnt % mod;
    }
    cout << res << endl;
    return 0;
}
```



#### 最大公约数





```c++
#include <iostream>
using namespace std;


int gcd(int a, int b)
{
    return b ? gcd(b, a % b): a;
}
int main()
{
    int n;
    cin >> n;
    while(n --)
    {
        int a, b;
        cin >> a >> b;
        cout << gcd(a, b) <<endl;
    }
    return 0;
}
```



## 欧拉函数

$\phi(n)$：1~n中与n互质的数的个数被称为欧拉函数，记为$\phi(n)$.

由算数基本定理：$$n = p_1^{k_1}p_2^{k_2}...p_t^{k_t}$$,

那么有：$\phi(n)=n * (1 - \frac{1}{p_1}) * (1 - \frac{1}{p_2})*....*(1 - \frac{1}{p_n})$.

#### 欧拉函数

```c++
#include <iostream>
#include <unordered_map>
using namespace std;

const int N = 101;

int get_eulers(int x)
{
    int res = x;
    for(int i = 2; i <= x/i; i ++)
    {
        if(x % i == 0)
        {
            res = res / i * (i-1);
            while(x % i == 0) x /= i;
        }
    }
    if (x > 1) res = res / x * (x - 1);
    return res;
}

int main()
{
    int n;
    cin >> n;
    while(n --)
    {
        int a;
        cin >> a;
        cout << get_eulers(a) << endl;
    }
    return 0;
}
```



python：

```python
def get_euler(x):
    res = x
    i = 2
    while i <= x // i:
        if x % i == 0:
            res = res / i * (i - 1)
            while x % i  == 0:
                x /= i
        i += 1
    if x > 1: res = res / x * (x - 1)
    return int(res)
if __name__ == "__main__":
    n = int(input())
    for  _ in range(n):
        x = int(input())
        print(get_euler(x))
```



#### 筛法求欧拉函数

求`1~n`中每一个数的欧拉函数$\phi(i)$：：时间复杂度$O(n)$.

* `i`是一个质数，那么有$\phi(i) = i - 1$

* `i mod pj == 0`，说明`pj`是`i`的一个质因子，因此$\phi(pj * i) = pj * \phi(i)$.
* `i mod pj != 0`，说明`pj`是`pj * i`的最小质因子，而且`pj`不包含在`i`的质因子中，因此$\phi(pj * i) = pj * \phi(i)*(1- \frac{1}{p_j}) = \phi(i) * (pj - 1)$

```

```

## 快速幂



![image-20200407212323378](https://tva1.sinaimg.cn/large/00831rSTgy1gdliryn33gj30ti0a4dhj.jpg)

```c++
#include <iostream>
using namespace std;

typedef long long ll;

ll qmi(int a, int b, int p)
{
    ll res = 1 % p;
    while(b)
    {
        if (b & 1) res = res * a % p;
        b >>= 1;
        a = (ll) a * a % p;
    }
    return res;
}
int main()
{
    int n; cin >> n;

    while( n --)
    {
        int a, b, p;
        cin >> a  >> b >> p;
        cout << qmi(a, b, p) << endl;
    }

    return 0;
}
```



​		

#### 快速幂求逆元



![image-20200407214014543](https://tva1.sinaimg.cn/large/00831rSTgy1gdlj9girmnj30xm0lmdss.jpg)

```c++
#include<iostream>

using namespace std;
typedef long long ll;

ll qmi(ll a,ll  b,ll  p)
{
    ll res = 1;
    while(b)
    {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
int main()
{
    int n; 
    cin >> n;
    while(n--)
    {
        ll a, p;
        cin >> a >> p;
        if(a % p == 0) cout << "impossible" << endl;
        else cout  << qmi(a, p -2, p) << endl;
    }
    
    return 0;
}
```





### 扩展欧几里得

求两个正整数 a 和 b 的 最大公约数 d
则有 gcd(a,b) = gcd(b,a%b)
证明：
    设  $a \% b = a - k \times b$ 其中$k = a/b$(向下取整)
    若d是(a,b)的公约数 则知 $d|a $且 $d|b $则易知 $d|a-k\times b$ 故d也是(b,a%b) 的公约数
    若d是(b,a%b)的公约数 则知$ d|b$ 且 $d|a-k*b$ 则 $d|a-k \times b+k \times b = d|a$ 故而d|b 故而 d也是(a,b)的公约数
    因此(a,b)的公约数集合和(b,a%b)的公约数集合相同 所以他们的最大公约数也相同 证毕#
引自：https://www.acwing.com/solution/AcWing/content/10534/





裴蜀定理：对于任意正整数a,b,一定存在非零整数x，y使得$ax + b y = gcd(a,b)$.，此时得到最小可以取到的数就是gcd(a,b)$。



欧几里得算法里我们用$gcd(a, b) = gcd(b, a\%b)$来做，对后式也有裴蜀定理。设$d = gcd(a, b)$式有：
$$
b*y + (a \mod b)*x = d \\
b*y + (a - \lfloor a/ b\rfloor *b) * x = d\\
a * x + b *(y - \lfloor a/ b\rfloor * x ) = d
$$
所以迭代下去只需要更新$y=y - \lfloor a/ b \rfloor * x$.

```c++
#include<iostream>

using namespace std;

typedef long long ll;

ll exgcd(ll a, ll b, int &x, int &y)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y = y - (a / b) * x;
    
    return d;
}

int main()
{
    int n;
    ll a, b;
    cin >> n;
    while(n--)
    {
        int x, y;
        cin >> a >> b;
        exgcd(a, b, x, y);
        cout << x << " " <<  y << endl;
    }
    
    return 0;
}
```



### 线性同余方程

给定$a, b,m$，求$a * x = b (\mod m)$.

有$a * x  = m * k + b$有$a * x + my=b$，假设有$a * x_0 + my_0 = d, d = gcd(a,m)$，若满足$gcd(a, m) | b$则有解，为$x= x_0 * b / gcd(a, m) \% m$。



```C++
#include<iostream>
#include<cstring>

using namespace std;

typedef long long LL;

int exgcd(int a, int b, int &x, int &y)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
        y -= a / b * x;
    return d;
}
int main()
{
    int n; scanf("%d", &n);
    while(n--)
    {
        int x, y;
        int a, b, m;
        scanf("%ld%ld%ld", &a, &b, &m);
        int d = exgcd(a, m, x, y);
        if(b % d) puts("impossible");
        else cout << (LL)x * b / d % m << endl;
    }
    return 0;
}
```





### 组合数2

![image-20200408120359351](https://tva1.sinaimg.cn/large/00831rSTgy1gdm886b1y9j31hi0pgqfv.jpg)



```c++
#include<iostream>
#include<cstring>

using namespace std;
typedef long long LL;
const int N = 100010, mod =1e9 + 7;
int fact[N], infact[N]; //fact[i]：i的阶乘；infact[i]:i的阶乘的逆元

int qmi(int a, int b, int p)
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}
int main()
{
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i++)
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod-2, mod) % mod;
    }
    int n;
    cin >> n;
    while(n --)
    {
        int a, b;
        cin >> a >> b;
        cout << (LL)fact[a]%mod * infact[b]%mod * infact[a- b]%mod << endl;
    }
    return 0;
}
```







### 组合数3



此时求$C_a^b \% p$，$p$为素数，但是给的$1\leq b \leq a \leq 10^{18}$.



lucas定理: 
$$
C_a^b = C_{(a \% p)}^{(b\%p)} * C_{(a / p)}^{(b / p)} \% p
$$


当$a< p$ 且 $b < p$ 时，直接计算$C_a^b\%p$，此时要用到：
$$
C_a^b =\frac{a* (a-1)\dots (a - b + 1)}{b!}
$$
在每次循环里，$a$ 减去1，$b$从1开始每次加1，除法变乘法用逆元$a * infact[b]$  代替$a / b$；

$p$为质数，$infact[b]=b^{(p-2)}$

```c++
#include<iostream>

using namespace std;
typedef long long LL;
LL gcd(LL a, LL b, LL p)
{
    LL res = 1;
    while(b)
    {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
LL C(LL a, LL b, LL p)
{
    LL res = 1;
    for(int i = 1, j = a; i <= b; i++, j --)
    {
        res = res * j % p;
        res = res * gcd(i, p - 2, p) % p; //除数用逆元算
    }
    return res % p;
}
LL lucas(LL a, LL b, LL p)
{
    if(a < p && b < p) return C(a, b, p);
    return lucas(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
int main()
{
    int n;
    cin >> n;
    while(n--)
    {
        LL a, b, p;
        cin >> a >> b >> p;
        cout << lucas(a, b, p) << endl;
    }
    return 0;
}
```







### 组合数4



求$C_a^b$，结果可能巨大，因此需要用到高精度计算。



对$C_a^b$做分解质因数
$$
C_a^b=\frac{a!}{b! * (a-b)!}=p_1^{x_1}*p_2^{x_2}\dots p_{n}^{x_n}
$$
$a!=\lfloor\frac{a}{p_1}\rfloor + \lfloor\frac{a_{2}}{p_2}\rfloor + \dots$， 其中$a_2 = \lfloor\frac{a}{p_1}\rfloor$



$\frac{a!}{b! * (a-b)!}$中的$p_i$个数等于分子的减去分母里的。



```c++
#include<iostream>
#include<vector>

using namespace std;
const int N = 5050;
int prime[N], sum[N], cnt;
bool st[N];

void get_prime(int a)
{
    for(int i = 2; i <= a; i++)
        if(!st[i])
        {
            st[i] = 1;
            prime[cnt++] = i;
            for(int j = i; j <= a; j+=i)
                st[j] = true;
        }
}

int get(int a, int p)
{
    int res = 0;
    while(a)
    {
        res += a / p;
        a /= p;
    }
    return res;
}

vector<int> mul(vector<int> a, int num)
{
    vector<int> res;
    int t = 0;
    for(int i = 0; i < a.size() || t; i++)
    {
        if(i < a.size()) t += a[i] * num;
        res.push_back(t % 10);
        t /= 10;
    }
    return res;
}
int main()
{
    int a, b;
    cin >> a >> b;
    get_prime(a);
    
    for(int i = 0; i< cnt; i++) //对于每个质数，看a、b、c中都有多少个
    {
        int p = prime[i];
        sum[i] = get(a, p) - get(b, p) - get(a - b, p);
    }
    
    vector<int> res;
    res.push_back(1);
    
    for(int i = 0; i < cnt; i++)
        for(int j = 0; j < sum[i]; j++)
            res = mul(res, prime[i]);
    for(int i = res.size() -1; i>=0; i--) cout << res[i];
    
    return 0;
}
```





### 满足条件的01序列



卡特兰数：
$$
C_{2n}^{n} - C_{2n}^{n-1}= \frac{C_{2n}^{n}}{n + 1}
$$




### 表达整数的奇怪方式



![image-20200411042949451](https://tva1.sinaimg.cn/large/00831rSTgy1gdpbyk9k2nj31dr0u0qot.jpg)



```c++
#include<iostream>
#include<cstring>

using namespace std;
typedef long long LL;
LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }
    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    
    return d;
}
int main()
{
    int n;
    cin >> n;
    LL a1, m1;
    cin >> a1 >> m1;
    bool ans = true;

    for(int i = 0; i < n - 1; i ++)
    {
        LL a2, m2;
        cin >> a2 >> m2;
        LL k1, k2;
        LL d = exgcd(a1, a2, k1, k2);
        if((m2 - m1) % d)
        {
            ans = false;
            break;
        }
        k1 = k1 * (m2 - m1)/ d;
        k1 = (k1 % (a2/d) + a2/d) % (a2/d);
        

        m1 = k1 * a1 + m1;
        a1 = a1 * a2 / d; 
        
    }
    
    if(ans) cout << (m1 % a1 + a1) % a1 << endl;
    else puts("-1");
    return 0;
    
}
```

